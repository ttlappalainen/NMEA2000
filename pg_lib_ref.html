<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<!-- BEGIN opengraph metadata -->
<meta property="og:title" content="NMEA2000 C++ library" />
<meta property="og:image" content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452" />
<meta property="og:description" content="Library to handle NMEA 2000 Communication written in C++." />
<meta property="og:url" content="https://github.com/ttlappalainen/NMEA2000" />
<!-- END opengraph metadata -->
<!-- BEGIN twitter metadata -->
<meta name="twitter:image:src" content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452" />
<meta name="twitter:title" content="NMEA2000 C++ library" />
<meta name="twitter:description" content="Library to handle NMEA 2000 Communication written in C++." />
<!-- END twitter metadata -->
<title>NMEA2000 Library: Reference for C++ library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" type="image/svg+xml" href="logo_sqare1.svg"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="toggle-alternative-theme.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeInteractiveToc.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-custom-alternative.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/ttlappalainen/NMEA2000" class="github-corner" title="View source on GitHub" target="_blank">
    <svg viewBox="0 0 250 250" width="40" height="40" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_s.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NMEA2000 Library
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">Library to handle NMEA 2000 Communication written in C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('pg_lib_ref.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Reference for C++ library </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md4">Introduction</a></li>
<li class="level1"><a href="#autotoc_md5">History</a></li>
<li class="level1"><a href="#autotoc_md6">Start from scratch and make your first NMEA2000 device with Arduino IDE</a></li>
<li class="level1"><a href="#autotoc_md7">Preparing to use NMEA2000 library</a></li>
<li class="level1"><a href="#autotoc_md8">Try NMEA2000 library with TemperatureMonitor example</a><ul><li class="level2"><a href="#autotoc_md9">Try on PC only</a></li>
<li class="level2"><a href="#autotoc_md10">A bit deeper look in to the TemperatureMonitor example</a><ul><li class="level3"><a href="#autotoc_md11">Change to use read real data</a></li>
<li class="level3"><a href="#autotoc_md12">Remove unnecessary messages</a></li>
<li class="level3"><a href="#autotoc_md13">Change the device and product information</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md14">Connecting your sample device to the NMEA2000 bus</a></li>
<li class="level2"><a href="#autotoc_md15">Try NMEA2000 library with WindMonitor example</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md16">Arduino Programming IDE</a><ul><li class="level2"><a href="#autotoc_md17">Getting started with Arduino Programming IDE</a></li>
<li class="level2"><a href="#autotoc_md18">Arduino Libraries</a></li>
<li class="level2"><a href="#autotoc_md19">Importing library from zip</a></li>
<li class="level2"><a href="#autotoc_md20">Importing libraries from GitHub</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md21">NMEA2000 library reference</a><ul><li class="level2"><a href="#autotoc_md22">Relevant Classes</a><ul><li class="level3"><a href="#autotoc_md23">Abstract base class tNMEA2000</a></li>
<li class="level3"><a href="#autotoc_md24">Abstract base class tNMEA2000::tMsgHandler</a></li>
<li class="level3"><a href="#autotoc_md25">Inherited classes according to your Board</a><ul><li class="level4"><a href="#autotoc_md26">Inherited class tNMEA2000_mcp</a></li>
<li class="level4"><a href="#autotoc_md27">Inherited class tNMEA2000_due</a></li>
<li class="level4"><a href="#autotoc_md28">Inherited class tNMEA2000_teensy</a></li>
<li class="level4"><a href="#autotoc_md29">Inherited class tNMEA2000_Teensyx</a></li>
<li class="level4"><a href="#autotoc_md30">Inherited class tNMEA2000_esp32</a></li>
<li class="level4"><a href="#autotoc_md31">Inherited class tNMEA2000_avr</a></li>
</ul>
</li>
<li class="level3"><a href="#autotoc_md32">Message container class tN2kMsg</a></li>
<li class="level3"><a href="#autotoc_md33">Group function (PGN 126208) handler class tN2kGroupFunctionHandler</a></li>
<li class="level3"><a href="#autotoc_md34">Device list collector class tN2kDeviceList</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md35">Using tNMEA2000</a><ul><li class="level3"><a href="#secDeviceModes">Device modes</a></li>
<li class="level3"><a href="#secMessageforwarding">Message forwarding</a></li>
<li class="level3"><a href="#descDebugMode">Debug mode</a></li>
<li class="level3"><a href="#descMultiDeviceSupport">Multi device support</a></li>
<li class="level3"><a href="#descRunningLibrary">Running library</a><ul><li class="level4"><a href="#autotoc_md36">Some timing examples</a></li>
<li class="level4"><a href="#descSystemMessages">System messages and library internal functionality</a></li>
</ul>
</li>
<li class="level3"><a href="#autotoc_md37">Member functions</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p ><a class="anchor" id="md_2_libRef"></a></p>
<h1><a class="anchor" id="autotoc_md4"></a>
Introduction</h1>
<p >NMEA2000 library is object oriented C++ library for developing NMEA2000 bus devices. Library fulfills automatically NMEA 2000 mandatory requirements (see <a class="el" href="md_7_glossary.html#secRefNMEA2000Certification">NMEA2000 certification</a>) leaving only interesting data handling for developer. <b>Library has been used in several commercial certified NMEA2000 devices.</b></p>
<p >To use NMEA2000 library you need basic skills for programming. For beginners I have tried to write simple instructions to start from scratch with Arduino IDE. When I started library development and even I had been doing sw and hw development for years, it took some time to dig information from internet to get started with Arduino based boards and do even simple tasks like installing library.</p>
<p >For using NMEA2000 library I prefer Teensy 4.0, 4.1, (or 3.2, 3.5, 3.6 which are end of life) or ESP32 with isolated ISO1050 or unisolated MCP2562 chip. For experienced users and big projects RPi can be also used.</p>
<p >For simple things Arduino Mega with CANBUS shield or schematics found under <a href="https://github.com/ttlappalainen/NMEA2000/tree/master/Documents">documents</a> is ok. I have not tested smaller boards and I prefer to forget any board less than 8 kB RAM.</p>
<h1><a class="anchor" id="autotoc_md5"></a>
History</h1>
<p >I started library development 2015 because I wanted to get rid of limitations of expensive devices on market. Also those did not had features I wanted. With my first own device for my yacht, I replaced three devices – NMEA0183 combiner, NMEA0183-&gt;NMEA2000 Converter, NMEA2000-&gt;PC converter - with single Arduino Due board and few extra chips.</p>
<p >On 2017 library was chosen for first commercial certified device. Later there has been several other commercial devices using my library. That has also made it important to keep it combatible and ready for certificated devices.</p>
<p >Since 2015 my personal work has moved more and more towards NMEA2000. I do commercially different NMEA2000 projects and consulting.</p>
<h1><a class="anchor" id="autotoc_md6"></a>
Start from scratch and make your first NMEA2000 device with Arduino IDE</h1>
<p >Lets think you have temperature sensor and you like to have it visible on NMEA2000 bus. Here I expect that:</p>
<ul>
<li>you already have Arduino Programming IDE installed. If not, do first “5.1 Getting started with Arduino Programming IDE”.</li>
<li>you know how to import .zip libraries to Arduino. If not, read help on “5.2.1 Importing library from zip”.</li>
<li>you have your Arduino board connected to USB on PC.</li>
<li>NOTE! Arduino IDE serial monitor must be closed!</li>
<li>You have right board selected from IDE Tools-Board” and right COM port selected from IDE Tools-Port:</li>
</ul>
<h1><a class="anchor" id="autotoc_md7"></a>
Preparing to use NMEA2000 library</h1>
<p >At first we have to download and install necessary libraries for Arduino and other useful tools. <br  />
 Download and install Arduino libraries according to your hardware see <a class="el" href="get_started.html#secHWlib">Hardware depended libraries</a>.</p>
<p >If you want to read or decode NMEA2000 messages, you can download and install “NMEA Reader”-application from <a href="http://www.actisense.com/media/?product=nmea-reader-and-ebl-reader">http://www.actisense.com/media/?product=nmea-reader-and-ebl-reader</a></p>
<h1><a class="anchor" id="autotoc_md8"></a>
Try NMEA2000 library with TemperatureMonitor example</h1>
<h2><a class="anchor" id="autotoc_md9"></a>
Try on PC only</h2>
<p >Now we are ready to try sample without N2k bus connection. So you need only Arduino board and PC. No CANBUS shield or extra chips yet!</p>
<ul>
<li>Open example <a class="el" href="_temperature_monitor_8ino.html" title="NMEA2000 library example. Send main cabin and water temperatures to the bus.">TemperatureMonitor.ino</a> sketch, which came with NMEA2000 library. Select from IDE “Open…”-libraries/NMEA2000-master/Example/TemperatureMonitor/TemperatureMonitor.ino</li>
<li>uncomment lines</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Serial.begin(115200);</span></div>
<div class="line"><span class="comment">// NMEA2000.SetForwardStream(&amp;Serial);</span></div>
</div><!-- fragment --><p >and comment line</p>
<div class="fragment"><div class="line"><a class="code hl_variable" href="_n_m_e_a2000___c_a_n_8h.html#a99f6ed3fa2b0b15f276c856e10a7a3ab">NMEA2000</a>.<a class="code hl_function" href="classt_n_m_e_a2000.html#a1981274e03fd52798eda7302b48ea169">EnableForward</a>(<span class="keyword">false</span>);</div>
<div class="ttc" id="a_n_m_e_a2000___c_a_n_8h_html_a99f6ed3fa2b0b15f276c856e10a7a3ab"><div class="ttname"><a href="_n_m_e_a2000___c_a_n_8h.html#a99f6ed3fa2b0b15f276c856e10a7a3ab">NMEA2000</a></div><div class="ttdeci">tNMEA2000 &amp; NMEA2000</div><div class="ttdef"><b>Definition:</b> <a href="_n_m_e_a2000___c_a_n_8h_source.html#l00350">NMEA2000_CAN.h:350</a></div></div>
<div class="ttc" id="aclasst_n_m_e_a2000_html_a1981274e03fd52798eda7302b48ea169"><div class="ttname"><a href="classt_n_m_e_a2000.html#a1981274e03fd52798eda7302b48ea169">tNMEA2000::EnableForward</a></div><div class="ttdeci">void EnableForward(bool v=true)</div><div class="ttdoc">Enable message forwarding to stream.</div><div class="ttdef"><b>Definition:</b> <a href="_n_m_e_a2000_8h_source.html#l02900">NMEA2000.h:2900</a></div></div>
</div><!-- fragment --><p >within <a class="el" href="_temperature_monitor_8ino.html#a4fc01d736fe50cf5b977f755b675f11d">setup()</a> function.</p>
<ul>
<li>If you are using Arduino Mega, uncomment line</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// NMEA2000.SetDebugMode(tNMEA2000::dm_Actisense); </span></div>
</div><!-- fragment --><p >within <a class="el" href="_temperature_monitor_8ino.html#a4fc01d736fe50cf5b977f755b675f11d">setup()</a> function.</p>
<p >We need to do this, since Mega board does not have build in CAN bus controller, so the library would fail, when it tries to open CAN on non debug mode.</p>
<ul>
<li>Upload sketch to board.</li>
<li>Start “NMEA Reader” and from toolbar dropdown select your Arduino COM port.</li>
</ul>
<p >Now you should see: <br  />
</p>
<div class="fragment"><div class="line">&quot;ISO address claim&quot; (PGN 60928)  </div>
<div class="line">&quot;Environmental parameters&quot; (PGN 130310) </div>
<div class="line">&quot;Environmental parameters&quot; (PGN 130311)  </div>
<div class="line">&quot;Temperature&quot; (PGN 130312)  </div>
</div><!-- fragment --><p >messages on “NMEA Reader”.</p>
<dl class="section note"><dt>Note</dt><dd>If you want to upload sketch again to the board, you have to release Arduino programming COM port by selecting port “- NOT SELECTED –“ on “NMEA Reader”.</dd></dl>
<h2><a class="anchor" id="autotoc_md10"></a>
A bit deeper look in to the TemperatureMonitor example</h2>
<p >First note that if you want to modify and save this sample, you have to save it on other location.</p>
<h3><a class="anchor" id="autotoc_md11"></a>
Change to use read real data</h3>
<p >If you are happy with sending only cabin and water temperatures to the N2k bus, you simply change functions double <a class="el" href="_temperature_monitor_8ino.html#a8c0bad38ce2f1d15032eb32fd5e9ca51">ReadCabinTemp()</a> and double <a class="el" href="_temperature_monitor_8ino.html#aa6891c1d6d986bb814a05c54e1b04e10">ReadWaterTemp()</a>. So e.g. if you have sensor providing 10 mV/ °C, you can change the function:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> <a class="code hl_function" href="_temperature_monitor_8ino.html#a8c0bad38ce2f1d15032eb32fd5e9ca51">ReadCabinTemp</a>() {</div>
<div class="line"><span class="keywordflow">return</span> (5.0 * analogRead(A0)*100/1024);</div>
<div class="line">}</div>
<div class="ttc" id="a_temperature_monitor_8ino_html_a8c0bad38ce2f1d15032eb32fd5e9ca51"><div class="ttname"><a href="_temperature_monitor_8ino.html#a8c0bad38ce2f1d15032eb32fd5e9ca51">ReadCabinTemp</a></div><div class="ttdeci">double ReadCabinTemp()</div><div class="ttdef"><b>Definition:</b> <a href="_temperature_monitor_8ino_source.html#l00087">TemperatureMonitor.ino:87</a></div></div>
</div><!-- fragment --><p >Do the same for <a class="el" href="_temperature_monitor_8ino.html#aa6891c1d6d986bb814a05c54e1b04e10">ReadWaterTemp()</a> (naturally you have to use other analog input e.g. A1) and you have your own ready NMEA2000 temperature monitor.</p>
<h3><a class="anchor" id="autotoc_md12"></a>
Remove unnecessary messages</h3>
<p >With the library N2k messages will be sent by call NMEA2000.SendMsg(N2kMsg). Before sending you have to setup the variable N2kMsg. In that example it has been done for Temperature message with call:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__group__msg_set_up.html#gaa330e786a6c3fab01b7ee8d8610d2159">SetN2kTemperature</a>(N2kMsg, 1, 1, <a class="code hl_enumvalue" href="_n2k_types_8h.html#ga8a1e9646b80c46fb414fa44bcfdca828a5b4a39860846300b35236f6b2ddc13ce">N2kts_MainCabinTemperature</a>, <a class="code hl_function" href="_temperature_monitor_8ino.html#a8c0bad38ce2f1d15032eb32fd5e9ca51">ReadCabinTemp</a>());</div>
<div class="ttc" id="a_n2k_types_8h_html_ga8a1e9646b80c46fb414fa44bcfdca828a5b4a39860846300b35236f6b2ddc13ce"><div class="ttname"><a href="_n2k_types_8h.html#ga8a1e9646b80c46fb414fa44bcfdca828a5b4a39860846300b35236f6b2ddc13ce">N2kts_MainCabinTemperature</a></div><div class="ttdeci">@ N2kts_MainCabinTemperature</div><div class="ttdoc">value is representing a main cabin temperature</div><div class="ttdef"><b>Definition:</b> <a href="_n2k_types_8h_source.html#l00176">N2kTypes.h:176</a></div></div>
<div class="ttc" id="agroup__group__msg_set_up_html_gaa330e786a6c3fab01b7ee8d8610d2159"><div class="ttname"><a href="group__group__msg_set_up.html#gaa330e786a6c3fab01b7ee8d8610d2159">SetN2kTemperature</a></div><div class="ttdeci">void SetN2kTemperature(tN2kMsg &amp;N2kMsg, unsigned char SID, unsigned char TempInstance, tN2kTempSource TempSource, double ActualTemperature, double SetTemperature=N2kDoubleNA)</div><div class="ttdoc">Setting up Message &quot;Temperature - DEPRECATED&quot; - PGN 130312.</div><div class="ttdef"><b>Definition:</b> <a href="_n2k_messages_8h_source.html#l04951">N2kMessages.h:4951</a></div></div>
</div><!-- fragment --><p >So if you do not need cabin temperature message (PGN 130312), simply delete that call SetN2kTemperature(…) and next call NMEA2000.SendMsg(N2kMsg); Similarly if you do not provide water temperature, delete calls SetN2kOutsideEnvironmentalParameters(…) and call NMEA2000.SendMsg(N2kMsg); after that. <br  />
 Now just upload sketch and open right port to “NMEA Reader” and you should see only "ISO address claim" (PGN 60928) and "Environmental parameters" (PGN 130311) on “NMEA Reader”.</p>
<h3><a class="anchor" id="autotoc_md13"></a>
Change the device and product information</h3>
<p >On NMEA2000 bus each device will tell to the bus what it is (see also <a class="el" href="md_7_glossary.html#secRefTermNAME">NAME</a>). This can be found on sample under <a class="el" href="_temperature_monitor_8ino.html#a4fc01d736fe50cf5b977f755b675f11d">setup()</a> function. Call SetDeviceInformation is important for right functionality on the bus. If you have only this own device on the bus, you can leave it like it is. In other case take deeper look in to the explanation for the function. Note that if you add several own devices to the bus, you have to configure parameters for this function so that each device will get unique <a class="el" href="md_7_glossary.html#secRefTermNAME">NAME</a> as a combination of these parameters.</p>
<p >Call SetProductInformation is not so important for own boat, but defines nice to know information. If you have some “Multi Function Display” (MFD) on the bus, it will show on the device list information set by this function. So you can e.g. set the “Manufacturer's Model ID” to “Jack’s temperature monitor” and version code and model version as you like, so on your MFD you can see that and choose right device.</p>
<h2><a class="anchor" id="autotoc_md14"></a>
Connecting your sample device to the NMEA2000 bus</h2>
<p >So now we have sketch, which works on the PC. If your sketch runs and shows information in “NMEA Reader”, it can be easily connected to the N2k bus. For electrical connection you need either CANBUS shield for Arduino Mega or you can build your own shield. You can find more information at <a class="el" href="page_h_w_set_up.html">Setting Up Hardware Environment</a>.</p>
<p >There is also drawing for Teensy on <a href="https://github.com/ttlappalainen/NMEA2000/blob/master/Examples/TeensyActisenseListenerSender/Documents/Teensy_Actisense_listener_sender_schematics.pdf">Teensy_Actisense_listener_sender_schematics.pdf</a>, which has additional USB with Pololu chip, which is only required for two USB solutions. So Prepare physical connection to the NMEA2000 bus and comment line:</p>
<div class="fragment"><div class="line"><a class="code hl_variable" href="_n_m_e_a2000___c_a_n_8h.html#a99f6ed3fa2b0b15f276c856e10a7a3ab">NMEA2000</a>.<a class="code hl_function" href="classt_n_m_e_a2000.html#a43fb8be0ab5036dff662192b04d20314">SetDebugMode</a>(<a class="code hl_enumvalue" href="classt_n_m_e_a2000.html#ae34b9115f8c45d6622089516a6d62c06a12a7a411e04a7856600454ad61ede1cc">tNMEA2000::dm_Actisense</a>);</div>
<div class="ttc" id="aclasst_n_m_e_a2000_html_a43fb8be0ab5036dff662192b04d20314"><div class="ttname"><a href="classt_n_m_e_a2000.html#a43fb8be0ab5036dff662192b04d20314">tNMEA2000::SetDebugMode</a></div><div class="ttdeci">void SetDebugMode(tDebugMode _dbMode)</div><div class="ttdoc">Set the Debug Mode of the system.</div><div class="ttdef"><b>Definition:</b> <a href="_n_m_e_a2000_8cpp_source.html#l01547">NMEA2000.cpp:1547</a></div></div>
<div class="ttc" id="aclasst_n_m_e_a2000_html_ae34b9115f8c45d6622089516a6d62c06a12a7a411e04a7856600454ad61ede1cc"><div class="ttname"><a href="classt_n_m_e_a2000.html#ae34b9115f8c45d6622089516a6d62c06a12a7a411e04a7856600454ad61ede1cc">tNMEA2000::dm_Actisense</a></div><div class="ttdeci">@ dm_Actisense</div><div class="ttdef"><b>Definition:</b> <a href="_n_m_e_a2000_8h_source.html#l00727">NMEA2000.h:727</a></div></div>
</div><!-- fragment --><p >within <a class="el" href="_temperature_monitor_8ino.html#a4fc01d736fe50cf5b977f755b675f11d">setup()</a> function, if you have previously uncommented it. Upload the sketch and check the result. <br  />
 On your NMEA2000 “Multi Function Display” (MFD, like Garmin GMI20) add temperature reading visible. For that I can not give more help, since each MFD has different user interface. Now you should see the temperature reading on your MFD.</p>
<p >If you are not interested in N2k bus messages and you want to add your own debug code, you have to disable message forwarding by uncommenting line:</p>
<div class="fragment"><div class="line"><a class="code hl_variable" href="_n_m_e_a2000___c_a_n_8h.html#a99f6ed3fa2b0b15f276c856e10a7a3ab">NMEA2000</a>.<a class="code hl_function" href="classt_n_m_e_a2000.html#a1981274e03fd52798eda7302b48ea169">EnableForward</a>(<span class="keyword">false</span>);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md15"></a>
Try NMEA2000 library with WindMonitor example</h2>
<p ><a class="el" href="_wind_monitor_8ino.html" title="NMEA2000 library example. Send main wind data to the bus.">WindMonitor.ino</a> is similar as TemperatureMonitor, but sends wind data to the bus. Only necessary function names has been changed. So follow the “Try NMEA2000 library with TemperatureMonitor example”.</p>
<h1><a class="anchor" id="autotoc_md16"></a>
Arduino Programming IDE</h1>
<h2><a class="anchor" id="autotoc_md17"></a>
Getting started with Arduino Programming IDE</h2>
<ul>
<li>Download and install <a href="https://www.arduino.cc/en/Main/Software">Arduino software</a> for suitable OS</li>
<li>If you are using Teensy based boards, download and install also <a href="https://www.pjrc.com/teensy/td_download.html">Teensyduino</a></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>With Teensyduino you have to check which version of Arduino IDE it supports! Check situation of Teensy FlexCAN library problem under <a href="https://github.com/ttlappalainen/NMEA2000/issues/50">https://github.com/ttlappalainen/NMEA2000/issues/50</a></dd></dl>
<ul>
<li>Start newly installed Arduino development IDE from “Arduino”-icon.</li>
<li>Connect your board to USB</li>
<li><p class="startli">Select right board for IDE from Tools-Board</p>
<dl class="section note"><dt>Note</dt><dd>If you have “Arduino Due” do not mix it to “Arduino Duemilanove”. Select “Arduino Due (programming port)”. If you do not have that in selection list add support for due board selecting Tools-Board:-“Boards Manager…”. Then type “due” to filter box and click found “Arduino SAM Boards…”. Then on left click “Install”</dd></dl>
</li>
<li>Select right COM port for IDE from Tools-Port: E.g. for Arduino Mega you should see on the list port: COMx (Arduino/Genuino Mega or Mega 2560)</li>
<li>Now open your first sketch to IDE. Open File-Examples-01.Basics-AnalogReadSerial</li>
<li>To see example output, open serial monitor: Tools-“Serial monitor”</li>
<li>Upload sketch by IDE toolbar button or from menu Sketch-Upload.</li>
<li>Now you should see board analog pin0 value running on serial monitor.</li>
</ul>
<p >Now you are ready for your own developing.</p>
<h2><a class="anchor" id="autotoc_md18"></a>
Arduino Libraries</h2>
<p >Arduino has both system wide and user libraries.</p>
<p >Arduino has both system wide and user libraries.</p>
<ul>
<li>System wide libraries are visible for all users and they are located as default e.g. on 64 bit Windows OS under "Program Files (x86)&gt;Arduino&gt;libraries"</li>
<li>User libraries are visible only for current user and they will be located as default e.g. on Windows OS under "Documents&gt;Arduino&gt;libraries"</li>
</ul>
<p >Arduino IDE installation automatically installs system wide libraries. When you add library with Arduino IDE, it will be added as default can make some library visible for all users by moving installed library from your personal libraries to system wide libraries. </p>
<h2><a class="anchor" id="autotoc_md19"></a>
Importing library from zip</h2>
<p >If someone points you direct link as .zip file to Arduino library, you need only:</p>
<ul>
<li>Download library to your PC</li>
<li>On Arduino IDE select Sketch-“Include Library”-“Add .ZIP Library…”</li>
<li>Navigate to you download path and select the .zip file you just downloaded and press Open.</li>
</ul>
<p >So now you should have that library on your personal libraries.</p>
<h2><a class="anchor" id="autotoc_md20"></a>
Importing libraries from GitHub</h2>
<p >Importing library from GitHub is also very simple. So you have heard or found good link to someone GitHub page.</p>
<ul>
<li>Open browser to the link. E.g. <a href="https://github.com/ttlappalainen">https://github.com/ttlappalainen</a></li>
<li>Select repository, which should contain the Arduino library you are looking for. E.g. NMEA2000 on link above.</li>
<li>Somewhere on page – currently on right – there is button “Clone or download”. Click that and then on popup button “Download ZIP” and choose “Save to disk” and press “OK”</li>
<li>Now just follow "Importing library from zip".</li>
</ul>
<h1><a class="anchor" id="autotoc_md21"></a>
NMEA2000 library reference</h1>
<p >NMEA2000 is closed standard. You can buy documents for it for high price. As far as I have understood, then you also accept that you are not allowed to tell any third party about document contents. So all the information and experience I have has been collected from free documents and mostly from OpenSkipper project, which development I have been continued. So there may be errors on library. Anyway have tried to make it simple to use, but still giving “NMEA2000 compatibility”.</p>
<h2><a class="anchor" id="autotoc_md22"></a>
Relevant Classes</h2>
<h3><a class="anchor" id="autotoc_md23"></a>
Abstract base class tNMEA2000</h3>
<p >The <a class="el" href="classt_n_m_e_a2000.html" title="tNMEA2000 device class definition.">tNMEA2000</a> class contains functions for NMEA2000 handling like e.g. sending and reading messages. This is purely an abstract class and to use a real device you must use an appropriate inherited class. Normally you use functions within this class.</p>
<h3><a class="anchor" id="autotoc_md24"></a>
Abstract base class tNMEA2000::tMsgHandler</h3>
<p >Inherit this class for your own message handler. When new message arrives, all attached handlers, which matches message PGN, will be called by ParseMessages. You can define this handler for single PGN or for all by setting PGN for base class to 0. You can also attach and detach class handler from <a class="el" href="classt_n_m_e_a2000.html" title="tNMEA2000 device class definition.">tNMEA2000</a> object.</p>
<h3><a class="anchor" id="autotoc_md25"></a>
Inherited classes according to your Board</h3>
<p >There are own inherited class for each CAN interface type. As described below e.g. for Arduino Due you use due_can and NMEA2000_due libraries. Since Arduino IDE 1.6.6 it has been possible to include libraries within other headers, so to use any of currently tested board you can simply add includes</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Arduino.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_n_m_e_a2000___c_a_n_8h.html">NMEA2000_CAN.h</a>&gt;</span></div>
<div class="ttc" id="a_n_m_e_a2000___c_a_n_8h_html"><div class="ttname"><a href="_n_m_e_a2000___c_a_n_8h.html">NMEA2000_CAN.h</a></div><div class="ttdoc">Automatic library selection according to the selected board.</div></div>
</div><!-- fragment --><p >"#include &lt;NMEA2000_CAN.h&gt;" will then automatically select right library according to the board you have selected on IDE (see <a class="el" href="_n_m_e_a2000___c_a_n_8h.html#aa4d481d7c4c5a9f3a5be9424619b1acf">USE_N2K_CAN</a>). If you want strictly control includes or the board will not be selected right by <a class="el" href="_n_m_e_a2000___c_a_n_8h.html" title="Automatic library selection according to the selected board.">NMEA2000_CAN.h</a>, use includes described on each inherited class or force selection with define before include. E.g.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Arduino.h&gt;</span></div>
<div class="line"><span class="preprocessor">#define USE_N2K_CAN 1  </span><span class="comment">// Force mcp_can</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_n_m_e_a2000___c_a_n_8h.html">NMEA2000_CAN.h</a>&gt;</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>You need to download hardware specific inherit classes separately. See <a class="el" href="get_started.html#secHWlib">Hardware depended libraries</a></dd></dl>
<h4><a class="anchor" id="autotoc_md26"></a>
Inherited class tNMEA2000_mcp</h4>
<p >The tNMEA2000_mcp is class for using library with CANBUS shield or according to schematic <a href="https://github.com/ttlappalainen/NMEA2000/blob/master/Documents/ArduinoMega_CAN_with_MCP2515_MCP2551.pdf">ArduinoMega_CAN_with_MCP2515_MCP2551.pdf</a>, which I have made for sample. <br  />
 To use this class, you need to include in your project beginning:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;SPI.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;mcp_can.h&gt;</span> </div>
<div class="line"><span class="preprocessor">#include &lt;NMEA2000_mcp.h&gt;</span></div>
<div class="line"><span class="preprocessor">#define N2k_SPI_CS_PIN 53  </span><span class="comment">// Pin for SPI Can Select</span></div>
<div class="line"><span class="preprocessor">#define N2k_CAN_INT_PIN 21 </span><span class="comment">// Use interrupt  and it is connected to pin 21</span></div>
<div class="line">tNMEA2000_mcp <a class="code hl_variable" href="_n_m_e_a2000___c_a_n_8h.html#a99f6ed3fa2b0b15f276c856e10a7a3ab">NMEA2000</a>(<a class="code hl_define" href="_n_m_e_a2000___c_a_n_8h.html#a3b620e8c35e1d4fb1ca29b5e07954650">N2k_SPI_CS_PIN</a>);</div>
<div class="ttc" id="a_n_m_e_a2000___c_a_n_8h_html_a3b620e8c35e1d4fb1ca29b5e07954650"><div class="ttname"><a href="_n_m_e_a2000___c_a_n_8h.html#a3b620e8c35e1d4fb1ca29b5e07954650">N2k_SPI_CS_PIN</a></div><div class="ttdeci">#define N2k_SPI_CS_PIN</div><div class="ttdoc">Definition of the SPI ChipSelectPin for the CAN Transceiver This defines the the I/O Pin uses for the...</div><div class="ttdef"><b>Definition:</b> <a href="_n_m_e_a2000___c_a_n_8h_source.html#l00325">NMEA2000_CAN.h:325</a></div></div>
</div><!-- fragment --><p> If you use automatic library selection, you need to any define CS pin (default 53) and interrupt pin (default 21), if they differ from defaults.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Arduino.h&gt;</span></div>
<div class="line"><span class="preprocessor">#define N2k_SPI_CS_PIN 52  </span><span class="comment">// Pin for SPI Can Select</span></div>
<div class="line"><span class="preprocessor">#define N2k_CAN_INT_PIN 10 </span><span class="comment">// Use interrupt  and it is connected to pin 21</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_n_m_e_a2000___c_a_n_8h.html">NMEA2000_CAN.h</a>&gt;</span></div>
</div><!-- fragment --><p >You can find the mcp_can library from <a href="https://github.com/ttlappalainen/CAN_BUS_Shield/archive/master.zip.">https://github.com/ttlappalainen/CAN_BUS_Shield/archive/master.zip.</a> Originally it was developed by SeedStudio <a href="https://github.com/Seeed-Studio/CAN_BUS_Shield">https://github.com/Seeed-Studio/CAN_BUS_Shield</a>. That library was last merged 18.09.2017. I have not yet tested changes after that.</p>
<h4><a class="anchor" id="autotoc_md27"></a>
Inherited class tNMEA2000_due</h4>
<p >The tNMEA2000_due class is for using library with Arduino Due, which has internal can bus controller. I personally prefer this board, since it is more powerful. It also has separate USB port. Also the physical interface to the bus is simpler. You can find sample schematic on <a href="https://github.com/ttlappalainen/NMEA2000/blob/master/Documents/ArduinoDUE_CAN_with_MCP2562.pdf">ArduinoDUE_CAN_with_MCP2562.pdf</a>. <br  />
 To use this class, you need to include in your project beginning:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;due_can.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;NMEA2000_due.h&gt;</span></div>
<div class="line">tNMEA2000_due <a class="code hl_variable" href="_n_m_e_a2000___c_a_n_8h.html#a99f6ed3fa2b0b15f276c856e10a7a3ab">NMEA2000</a>;</div>
</div><!-- fragment --><p >You can find the due_can library from <a href="https://github.com/ttlappalainen/due_can">due_can</a>. That had been originally forked from <a href="https://github.com/collin80/due_can">https://github.com/collin80/due_can</a>, but Collin library has some changes I have not tested.</p>
<h4><a class="anchor" id="autotoc_md28"></a>
Inherited class tNMEA2000_teensy</h4>
<p >The tNMEA2000_teensy class is for using library with Teensy 3.2, 3.5, 3.6 boards, which has internal can bus controller. Physical interface is similar as with Arduino Due. <br  />
 To use this class, you need to include in your project beginning:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;NMEA2000_teensy.h&gt;</span></div>
<div class="line">tNMEA2000_teensy <a class="code hl_variable" href="_n_m_e_a2000___c_a_n_8h.html#a99f6ed3fa2b0b15f276c856e10a7a3ab">NMEA2000</a>;</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md29"></a>
Inherited class tNMEA2000_Teensyx</h4>
<p >The tNMEA2000_Teensyx class is for using library with Teensy 3.2, 3.5, 3.6, 4.0, 4.1 boards, which has internal can bus controller. Physical interface is similar as with Arduino Due. <br  />
 To use this class, you need to include in your project beginning:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;NMEA2000_Teensyx.h&gt;</span></div>
<div class="line">tNMEA2000_teensy <a class="code hl_variable" href="_n_m_e_a2000___c_a_n_8h.html#a99f6ed3fa2b0b15f276c856e10a7a3ab">NMEA2000</a>;</div>
</div><!-- fragment --><p >At the moment automatic automatic library selection uses as default NMEA2000_teensy.h for Teensy 3.2, 3.5, 3.6. NMEA2000_Teensyx works reliably with old boards too so you can force it for automatic library selection</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Arduino.h&gt;</span></div>
<div class="line"><span class="preprocessor">#define USE_NMEA2000_TEENSYX_FOR_TEENSY_3X </span><span class="comment">// Force NMEA2000_TEENSYX also for Teensy 3.x boards</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_n_m_e_a2000___c_a_n_8h.html">NMEA2000_CAN.h</a>&gt;</span></div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md30"></a>
Inherited class tNMEA2000_esp32</h4>
<p >The tNMEA2000_esp32 class is for using library with ESP32 based boards, which has internal can bus controller. Physical interface is similar as with Arduino Due or Teensy. <br  />
 To use this class, you need to include in your project beginning:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;NMEA2000_esp32.h&quot;</span></div>
<div class="line">tNMEA2000_esp32 <a class="code hl_variable" href="_n_m_e_a2000___c_a_n_8h.html#a99f6ed3fa2b0b15f276c856e10a7a3ab">NMEA2000</a>;</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md31"></a>
Inherited class tNMEA2000_avr</h4>
<p >The tNMEA2000_teensy class is for using library avr based boards. I have not yet experience of them, but thomasonw uses them. To use this class, you need to include in your project beginning:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;NMEA2000_avr.h&quot;</span></div>
<div class="line">tNMEA2000_avr <a class="code hl_variable" href="_n_m_e_a2000___c_a_n_8h.html#a99f6ed3fa2b0b15f276c856e10a7a3ab">NMEA2000</a>;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md32"></a>
Message container class tN2kMsg</h3>
<p >This is the class for containing N2k (PGN) message. It contains pure data and functions to handle it. At least for now there is no automated system, which could you easily fill or read data for specific PGN. You have to know the PGN information fields like for NMEA0183 data fields. I and other developers have written functions, which has been defined on <a class="el" href="_n2k_messages_8h.html" title="This File contains all SetXXX functions which will be needed to transfer data with a specific PGN.">N2kMessages.h</a>, which helps you the fill or read data on <a class="el" href="classt_n2k_msg.html" title="This class contains all the data of an NMEA2000 message.">tN2kMsg</a> object. <br  />
</p>
<p >As in example TemperatureMonitor you send PGN 130312 (Temperature) message with simple code:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classt_n2k_msg.html">tN2kMsg</a> N2kMsg;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="group__group__msg_set_up.html#gaa330e786a6c3fab01b7ee8d8610d2159">SetN2kTemperature</a>(N2kMsg, 1, 1, <a class="code hl_enumvalue" href="_n2k_types_8h.html#ga8a1e9646b80c46fb414fa44bcfdca828a5b4a39860846300b35236f6b2ddc13ce">N2kts_MainCabinTemperature</a>, <a class="code hl_function" href="_temperature_monitor_8ino.html#a8c0bad38ce2f1d15032eb32fd5e9ca51">ReadCabinTemp</a>());</div>
<div class="line"><a class="code hl_variable" href="_n_m_e_a2000___c_a_n_8h.html#a99f6ed3fa2b0b15f276c856e10a7a3ab">NMEA2000</a>.<a class="code hl_function" href="classt_n_m_e_a2000.html#a6d2b2e0ffd57aca912cda44e868cd25b">SendMsg</a>(N2kMsg);</div>
<div class="ttc" id="aclasst_n2k_msg_html"><div class="ttname"><a href="classt_n2k_msg.html">tN2kMsg</a></div><div class="ttdoc">This class contains all the data of an NMEA2000 message.</div><div class="ttdef"><b>Definition:</b> <a href="_n2k_msg_8h_source.html#l00655">N2kMsg.h:656</a></div></div>
<div class="ttc" id="aclasst_n_m_e_a2000_html_a6d2b2e0ffd57aca912cda44e868cd25b"><div class="ttname"><a href="classt_n_m_e_a2000.html#a6d2b2e0ffd57aca912cda44e868cd25b">tNMEA2000::SendMsg</a></div><div class="ttdeci">bool SendMsg(const tN2kMsg &amp;N2kMsg, int DeviceIndex=0)</div><div class="ttdoc">Send message to the NMEA2000 bus.</div><div class="ttdef"><b>Definition:</b> <a href="_n_m_e_a2000_8cpp_source.html#l01450">NMEA2000.cpp:1450</a></div></div>
</div><!-- fragment --><p >So as you see, you do not need to know much about <a class="el" href="classt_n2k_msg.html" title="This class contains all the data of an NMEA2000 message.">tN2kMsg</a> to use it. It is simple container.</p>
<dl class="section note"><dt>Note</dt><dd>There are functions SetN2k130312 and inline function SetN2kTemperature, which simply calls SetN2kPGN130312. This makes code easier to read (I hope), since you do not need to see PGN numbers there. But it’s your choice, which function you will use. <br  />
</dd>
<dd>
If you need something, which is not already on <a class="el" href="_n2k_messages_8h.html" title="This File contains all SetXXX functions which will be needed to transfer data with a specific PGN.">N2kMessages.h</a>, I’ll add it there or if you are familiar with NMEA 2000 message structures and Github, you can fork library and add it yourself. So then it is available for anybody.</dd></dl>
<h3><a class="anchor" id="autotoc_md33"></a>
Group function (PGN 126208) handler class tN2kGroupFunctionHandler</h3>
<p >NMEA 2000 definition requires than devices should respond group function messages. This class is default handler, which simply responds “unsupported” for all queries. <br  />
 see <a class="el" href="classt_n2k_group_function_handler.html">tN2kGroupFunctionHandler</a></p>
<h3><a class="anchor" id="autotoc_md34"></a>
Device list collector class tN2kDeviceList</h3>
<p >This class can be used to read devices on the connected NMEA 2000 bus. When class has been attached to <a class="el" href="classt_n_m_e_a2000.html" title="tNMEA2000 device class definition.">tNMEA2000</a> object, it will automatically collect and update information of devices on the bus. On the NMEA 2000 bus all devices (also called nodes) has own source address. The source addressmay be changed due to <a class="el" href="md_7_glossary.html#secRefTermAddressClaiming">address claiming</a> on power up or when new device will be added to the bus. For this reason source address can not be used as only filter for similar messages like position data. By using <a class="el" href="classt_n2k_device_list.html" title="Helper class to keep track of all devices on the bus.">tN2kDeviceList</a> source address related to <a class="el" href="md_7_glossary.html#secRefTermNAME">NAME</a> can be easily found at any time with <a class="el" href="classt_n2k_device_list.html" title="Helper class to keep track of all devices on the bus.">tN2kDeviceList</a> functions.</p>
<p >In principle on steady system source will stay unchanged. The safer way is to use device <a class="el" href="md_7_glossary.html#secRefTermNAME">NAME</a> which should be unique. So if you e.g., have two speed logs and you want to specify the one you want to use, you can use <a class="el" href="classt_n2k_device_list.html" title="Helper class to keep track of all devices on the bus.">tN2kDeviceList</a> class to search source address for specified NAME and then read log messages from that source.</p>
<p >See also example <a class="el" href="_device_analyzer_8ino.html" title="NMEA2000 library example. Show devices on NMEA2000 bus by using tN2kDeviceList.">DeviceAnalyzer.ino</a>.</p>
<h2><a class="anchor" id="autotoc_md35"></a>
Using tNMEA2000</h2>
<p >There are several examples for using library with different functions like for only listen bus data (ActisenseListener.ino), sending temperature (<a class="el" href="_temperature_monitor_8ino.html" title="NMEA2000 library example. Send main cabin and water temperatures to the bus.">TemperatureMonitor.ino</a>) or wind data (<a class="el" href="_wind_monitor_8ino.html" title="NMEA2000 library example. Send main wind data to the bus.">WindMonitor.ino</a>) from your own sources or displaying bus data somehow (DisplayData.ino and DisplayData2.ino).</p>
<p >Library core has all functionalities to communicate with NMEA2000 bus and <a class="el" href="_n2k_messages_8h.html" title="This File contains all SetXXX functions which will be needed to transfer data with a specific PGN.">N2kMessages.h</a> has simple functions to read and set most common messages. And you can add own modules to support missing messages. Rest is up to your imagination.</p>
<p >Below is short description of member functions, which hopefully gives you better knowledge why something has been used on samples.</p>
<h3><a class="anchor" id="secDeviceModes"></a>
Device modes</h3>
<p >For historical reasons library offers several message handling modes. One idea was that CAN controller specific drivers could drop some data handling, but it is not implemented on any of them. Practically only modes</p><ul>
<li>N2km_ListenAndNode for real bus devices.</li>
<li>N2km_ListenAndSend for message pass trough devices.</li>
</ul>
<p >would be enough.</p>
<p >"Listen" in mode definition refers to message forwarding. Mode definitions without "Listen" passes forward functionality. On the other hand forwarding can be enabled or disabled with <a class="el" href="classt_n_m_e_a2000.html#a1981274e03fd52798eda7302b48ea169" title="Enable message forwarding to stream.">tNMEA2000::EnableForward()</a>, which then makes other modes less necessary. Also mode can not be changed after open, but forward can be enabled or disabled at any time - this makes listen modes be more usefull. And last since drivers does not limit messages by mode message handlers will be called anyway allowing you to control messages in your code and even build own "message forwarding".</p>
<p >Although there should be no reason to use other than N2km_ListenAndNode or N2km_ListenAndSend modes, below is table of different modes effect.</p><ul>
<li>Tx = messages can be sent</li>
<li>Rx = messages can be received</li>
<li>Dev = acts as active bus device. Has full functionality like address claiming, heartbeat, response to requests.</li>
<li>Fen = Message forwarding - <a class="el" href="classt_n_m_e_a2000.html#a1981274e03fd52798eda7302b48ea169" title="Enable message forwarding to stream.">tNMEA2000::EnableForward()</a> does have effect</li>
<li>S = Setting <a class="el" href="classt_n_m_e_a2000.html#a205933011fd3895e30d134016a086faa" title="Enable System Messages for forwarding.">tNMEA2000::SetForwardSystemMessages</a> does have effect.</li>
</ul>
<p >(x) means that feature is not limited by core library, but could have limit on "driver".</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Mode   </th><th class="markdownTableHeadCenter">Tx   </th><th class="markdownTableHeadCenter">Rx   </th><th class="markdownTableHeadCenter">Dev   </th><th class="markdownTableHeadCenter">Fen   </th><th class="markdownTableHeadCenter">S    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">N2km_NodeOnly   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">N2km_ListenAndNode   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">N2km_ListenAndSend   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter"></td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">N2km_ListenOnly   </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">x    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">N2km_SendOnly   </td><td class="markdownTableBodyCenter">x   </td><td class="markdownTableBodyCenter">(x)   </td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td><td class="markdownTableBodyCenter"></td></tr>
</table>
<p >NMEA2000 requires that all devices should act as active device (also called node) on the NMEA2000 bus. Total electrical bus load can be then calculated and there will not be any hidden devices. If you take care that bus load will not be exceeded, it should not be risky to make listen only devices for you own boat.</p>
<p >You can set your device mode on setup with function <a class="el" href="classt_n_m_e_a2000.html#ad43803ecc3b2aeaa5ee633321a6ff867" title="Set the library mode and start source address.">tNMEA2000::SetMode()</a>. See also <a class="el" href="classt_n_m_e_a2000.html#a5af29eea6c5efd234d6f94ff3b6823c6" title="System mode defines how the device will behave on the NMEA2000 bus.">tNMEA2000::tN2kMode</a> .</p>
<h3><a class="anchor" id="secMessageforwarding"></a>
Message forwarding</h3>
<p >Message forwarding offers simple way to forward messages to defined stream in Actisense format. I build this functionality inside library to easily analyze bus messages even device does have its own functionality like temperature sensor. Now when I have mostly used ESP32 with WiFi, I can enable forwarding on the fly to UDP stream for any device and use it as analyzer.</p>
<p >In any listen mode, the device will read all messages from N2k bus and forwards them to the defined forward stream. For forwarding you just define a forward stream - e.g., serial port, UDP stream - with function <a class="el" href="classt_n_m_e_a2000.html#a2d9e7390622f0aaa3dd96e753d0f3ab7">tNMEA2000::SetForwardStream</a> and enable forward with tNMEA2000::EnableForward(true). Naturally you also need to open a stream first e.g. with Serial.begin(115200);</p>
<p >Messages will be forwarded as default in Actisense format. This format is supported by at least some PC chart plotter applications. You can show Actisence format messages with “NMEA Reader”, which I refer time to. Best program for bus data analyzing is my NMEA Simulator <a href="http://www.kave.fi/Apps/">http://www.kave.fi/Apps/</a>. For data visualizer you can use e.g., OpenSkipper, on which you can tailor your own displays. <br  />
</p>
<p >If message forwarding is enabled, own messages send with <a class="el" href="classt_n_m_e_a2000.html#a6d2b2e0ffd57aca912cda44e868cd25b" title="Send message to the NMEA2000 bus.">tNMEA2000::SendMsg</a> will be forwarded as default even when your device has been set to node only mode. If this disturbs your developing, if you e.g. want to write own clear text messages within your code, you can disable that by either:</p>
<ul>
<li>tNMEA2000::EnableForward(false) to disable forwarding totally</li>
<li>tNMEA2000::SetForwardOwnMessages(false) to disable own message forwarding. In listen mode messages from bus will be still forwarded.</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="pg_lib_ref.html#secDeviceModes">Device modes</a></li>
<li><a class="el" href="classt_n_m_e_a2000.html#a2d9e7390622f0aaa3dd96e753d0f3ab7">tNMEA2000::SetForwardStream</a></li>
<li><a class="el" href="classt_n_m_e_a2000.html#a1981274e03fd52798eda7302b48ea169">tNMEA2000::EnableForward</a></li>
<li><a class="el" href="classt_n_m_e_a2000.html#a3b1e14f74064caed4c3583bfbbe13134">tNMEA2000::SetForwardOwnMessages</a></li>
<li><a class="el" href="classt_n_m_e_a2000.html#a36a00385b554ec225cab2819f6371d8f">tNMEA2000::SetForwardOnlyKnownMessages</a></li>
<li><a class="el" href="classt_n_m_e_a2000.html#a205933011fd3895e30d134016a086faa">tNMEA2000::SetForwardSystemMessages</a>.</li>
</ul>
</dd></dl>
<h3><a class="anchor" id="descDebugMode"></a>
Debug mode</h3>
<p >Debug mode is as default set to <a class="el" href="classt_n_m_e_a2000.html#ae34b9115f8c45d6622089516a6d62c06ab353e783fc41310b95e0f58cf43450f1">tNMEA2000::dm_None</a>. In other debug modes device will not send anything to the N2k bus. Debug mode <a class="el" href="classt_n_m_e_a2000.html#ae34b9115f8c45d6622089516a6d62c06a12a7a411e04a7856600454ad61ede1cc">tNMEA2000::dm_Actisense</a> is usefull, if you do not have board with internal CAN bus controller, because in that mode it does not try to open CAN bus during sending message. Instead it simply writes message to the forward stream, which you can read e.g. with “NMEA Reader” and see that your device is sending message right. <br  />
</p>
<p >Debug mode <a class="el" href="classt_n_m_e_a2000.html#ae34b9115f8c45d6622089516a6d62c06a029f6117be0b53250dc470fade27842f">tNMEA2000::dm_ClearText</a> defines that messages will be send to forward stream as clear text. Unfortunately on clear text there are only source, destination, priority data length and PGN shown as clear text. Data itself will be shown as hex. <br  />
</p>
<h3><a class="anchor" id="descMultiDeviceSupport"></a>
Multi device support</h3>
<p >In NMEA 2000 bus you have devices or also called nodes. Normally each physical device is one device on the bus. I have not seen any requirement that a device could not serve as engine information (device class 50 – propulsion) or sensor information (device class 75 - Sensor Communication Interface) interface at same time and just use device class 25 (Inter/Intranetwork Device) and function 132 (Analog to NMEA 2000 Gateway). Anyway I have found that e.g. B&amp;G Vulcan 7 chartplotter acts as multi device. I do not know are these devices different chips inside Vulcan or are they within same code as my multi device. <br  />
 If you like show different functions as own device on the bus, you can do that with multi device support. All you need to do is to first set device count (see <a class="el" href="classt_n_m_e_a2000.html#afaee7e8972200217c229b7d471175562" title="Set the count of devices library shows on bus.">tNMEA2000::SetDeviceCount</a>), set device and product information for each device and on sending messages use right device index. See example MultiDevice.</p>
<h3><a class="anchor" id="descRunningLibrary"></a>
Running library</h3>
<p >Library has been designed to work without need for multitasking system. After setup it is critical to call <a class="el" href="classt_n_m_e_a2000.html#a19d8850b16c1204911ada74c267a5f6d" title="Parse all incoming Messages.">tNMEA2000::ParseMessages</a> in loop as fast as possible. By that call library handles many basic required features like address claiming, responding to system requests, heartbeat sending etc.</p>
<p >Fast loop requirement means that you are not allowed to use any delay on your loop or any other library using delay or blocking read. Delays withing loop in worst case causes that other devices on your NMEA2000 bus drops your device from the list and then pops it up again. If you have e.g., configured your MFD to show temperature from your device, it may appear and disappear on the screen.</p>
<p >A practice has shown that random 10-50 ms delay is acceptable. In average loop time should be less than 2 ms. Also it is important that if you can have up 50 ms random delay, you may get in burst up to 90 frames (=1800 frames/s *0.05 s) during that time. This means that if your receive frame buffer is smaller, your device may loose some critical system messages. In small boat this amount is a bit theory, but anyway there are a lot of large messages just from GPS system so that they may occur time to time at same time. So it is better to prepare your device work in nearly any condition.</p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="classt_n_m_e_a2000.html#a19d8850b16c1204911ada74c267a5f6d">tNMEA2000::ParseMessages</a></li>
<li><a class="el" href="classt_n_m_e_a2000.html#a944240f03999812fc365a00bc2b37d47">tNMEA2000::SetN2kCANReceiveFrameBufSize()</a></li>
<li><a class="el" href="classt_n_m_e_a2000.html#a5e09e469c4126963e26802c4541117bb">tNMEA2000::SetN2kCANSendFrameBufSize()</a></li>
</ul>
</dd></dl>
<h4><a class="anchor" id="autotoc_md36"></a>
Some timing examples</h4>
<p >If you use DallasTemperature library as default you may block loop up to 700 ms. By using it "asynchronously", delays are smaller and may be acceptable. Best solution would be to use some kind of hardware based library like esp32-owb for ESP32.</p>
<p >Some ADC libraries blocks loop during conversion, which may be 200-400 ms for high resolution ADC with averaging. ADC:s should be always used so that conversion will be started and then quickly checked, when conversion is ready. Even better if you know conversion time and check it after you expect it should be ready.</p>
<p >Some displays are very slow for writing. Writing some text may take 100 ms causing too long delay and problems with bus. Depending of library, it may also have some kind of buffering to get write request and flag, when it has been finished without blocking call. If there is not, it is often possible write own higher level buffering, which finally writes to display letter by letter and so spent only short time on each call.</p>
<p >With serial line use always available and availableForWrite features to avoid blocking. Also it helps if you can define bigger harware buffers.</p>
<p >In multitasking system someone had defined <a class="el" href="classt_n_m_e_a2000.html#a19d8850b16c1204911ada74c267a5f6d" title="Parse all incoming Messages.">tNMEA2000::ParseMessages</a> task time to 100 ms. I do not wonder, if there will random strange problems with that device. 1 ms task time would be acceptable.</p>
<h4><a class="anchor" id="descSystemMessages"></a>
System messages and library internal functionality</h4>
<p >Library has been designed to do automatically as many required features as possible. In this way user can concentrate to his own code and does not need to know everything about NMEA2000 low level. There is several system messages, which are handled automatically and user does not need to take care of.</p>
<ul>
<li>PGN 59392 ISO Acknowledgement.<ul>
<li>Library responds with NAK for unhandled requests.</li>
</ul>
</li>
<li>PGN 59904 ISO Request.<ul>
<li>Library handles ISO request for system messages.</li>
<li>For other messages library calls ISORequestHandler. See <a class="el" href="classt_n_m_e_a2000.html#a1a3c14ee0a90bcdee2c2d8446db00805" title="Set the message handler for incoming ISO Requests.">tNMEA2000::SetISORqstHandler</a>.</li>
</ul>
</li>
<li>PGN 60928 ISO Address Claim.<ul>
<li>Library starts address claiming procedure automatically and handles it completely.</li>
<li>Library responds as required to others address claiming, if necessary. See also <a class="el" href="classt_n_m_e_a2000.html#ad0763a8d6bec7d9dee647e9a695206f4" title="Check if this device has changed its address.">tNMEA2000::ReadResetAddressChanged</a>.</li>
<li>Library handles normal requests and group function requests to change device or system instances. See also <a class="el" href="classt_n_m_e_a2000.html#ae3fb4cf2ef6601527153715e8c088e24" title="Check if this device has changed its DeviceInstances or SystemInstance.">tNMEA2000::ReadResetDeviceInformationChanged</a>.</li>
<li>If you need to track devices on the bus e.g., to tie some message to specific device there is automatic module <a class="el" href="classt_n2k_device_list.html" title="Helper class to keep track of all devices on the bus.">tN2kDeviceList</a> to do work for you.</li>
</ul>
</li>
<li>PGN 60416 and PGN 60160 ISO Transport Protocol messages.<ul>
<li>Library hadles automatically message sending and receiving with ISO TP.</li>
</ul>
</li>
<li>PGN 126208 Group Function message.<ul>
<li>Library does default handling for system messages.</li>
<li>For other messages library forwards handling to class inherited from <a class="el" href="classt_n2k_group_function_handler.html" title="Base handler class for Group Functions.">tN2kGroupFunctionHandler</a>. See <a class="el" href="classt_n_m_e_a2000.html#a69175692dee5cc123f2571a93ae50d44" title="Add a message handler for incoming Group Function messages.">tNMEA2000::AddGroupFunctionHandler</a>.</li>
</ul>
</li>
<li>PGN 126464 Receive/Transmit PGN list.<ul>
<li>Library responds automatically for requested PGN lists. User has to take care that own PGNs has been declared at startup with <a class="el" href="classt_n_m_e_a2000.html#a9f00a2ef1a2e923506133a208bcbcbae" title="Send a list with all supported Transmit messages.">tNMEA2000::SendTxPGNList</a> and <a class="el" href="classt_n_m_e_a2000.html#a9a6499c7ff0814d3a7d74e55874ee379" title="Send a list with all supported Receive messages.">tNMEA2000::SendRxPGNList</a>.</li>
</ul>
</li>
<li>PGN 126993 Heartbeat.<ul>
<li>Library takes care of heartbeat sending.</li>
<li>Library also takes care of heartbeat offset/period change requests.</li>
</ul>
</li>
<li>PGN 126996 Product information.<ul>
<li>Library responds automatically to product information requests. User has to setup product information at device start with <a class="el" href="classt_n_m_e_a2000.html#a08b0d31c74617227329406d948059a76" title="Set the Product Information of this device.">tNMEA2000::SetProductInformation</a>.</li>
</ul>
</li>
<li>PGN 126998 Configuration information.<ul>
<li>Library responds automatically to configuration information requests. User has to setup configuration information at device start with <a class="el" href="classt_n_m_e_a2000.html#af9a5602533a0af28ae483cc1cd0913fb" title="Set the Configuration Information of this device.">tNMEA2000::SetConfigurationInformation</a>.</li>
<li>Library also updates Installation Description 1 and 2 on request. See also <a class="el" href="classt_n_m_e_a2000.html#a343eb326c46fd23a03c39f44ee7f838a" title="Check if this device has changed its Install Description.">tNMEA2000::ReadResetInstallationDescriptionChanged</a>.</li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="autotoc_md37"></a>
Member functions</h3>
<hr  />
<p> <a class="anchor" id="autotoc_md39"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#a08b0d31c74617227329406d948059a76" title="Set the Product Information of this device.">tNMEA2000::SetProductInformation</a></h5>
<p >Set the Product Information of this device. With this function you define how your device will show up for other devices on NMEA2000 bus.</p>
<p >Define your product information. Defaults will be set on initialization. For keeping defaults use 0xffff/0xff for int/char values and null ptr for pointers. LoadEquivalency is multiplication of 50 mA, what your device will take power from NMEA2000 bus. E.g. for Arduino only it can be 1 (=50mA). If your device does not take power from bus, set this to 0.</p>
<p >If you use device modes <a class="el" href="classt_n_m_e_a2000.html#a5af29eea6c5efd234d6f94ff3b6823c6a4cd03ae74ee5aa6a957d14c523af52d4">tNMEA2000::N2km_ListenOnly</a>, <a class="el" href="classt_n_m_e_a2000.html#a5af29eea6c5efd234d6f94ff3b6823c6af7e9ed093b1332630ad82fb17f87588d">tNMEA2000::N2km_ListenAndSend</a> or N2km_SendOnly, function does not have effect.</p>
<dl class="section note"><dt>Note</dt><dd>Serial code has length of 32 so just long enough to carry GUID.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_ModelSerialCode</td><td>Default="00000001". Max 32 chars. Manufacturer's Model serial code </td></tr>
    <tr><td class="paramname">_ProductCode</td><td>Default=666. Manufacturer's product code. For certified devices this number will be given by NMEA organization. </td></tr>
    <tr><td class="paramname">_ModelID</td><td>Default="Arduino N2k-&gt;PC". Max 33 chars. Manufacturer's Model ID </td></tr>
    <tr><td class="paramname">_SwCode</td><td>Default="1.0.0.0". Max 40 chars. Manufacturer's software version code </td></tr>
    <tr><td class="paramname">_ModelVersion</td><td>Default="1.0.0". Max 24 chars. Manufacturer's Model version </td></tr>
    <tr><td class="paramname">_LoadEquivalency</td><td>Default=1. x * 50 mA </td></tr>
    <tr><td class="paramname">_N2kVersion</td><td>Default=2101 </td></tr>
    <tr><td class="paramname">_CertificationLevel</td><td>Default=1 </td></tr>
    <tr><td class="paramname">iDev</td><td>index of the device on Devices</td></tr>
  </table>
  </dd>
</dl>
<hr  />
<p> <a class="anchor" id="autotoc_md41"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#a1cb4d59a06724fcb32c6986b21c526a5" title="Set the Device Information. See also NAME.">tNMEA2000::SetDeviceInformation</a></h5>
<p >Set the Device Information. See also <a class="el" href="md_7_glossary.html#secRefTermNAME">NAME</a>. If you use device modes <a class="el" href="classt_n_m_e_a2000.html#a5af29eea6c5efd234d6f94ff3b6823c6a9b42ab0462e8df393c8ce78170926e18">tNMEA2000::N2km_NodeOnly</a> or <a class="el" href="classt_n_m_e_a2000.html#a5af29eea6c5efd234d6f94ff3b6823c6ac0fcabeda748be43650dce09d6fb4d7c">tNMEA2000::N2km_ListenAndNode</a>, it is critical that you set this information.</p>
<p >Device information will be used to choose right address for your device (also called node) on the bus. Each device must have an own address. Library will do this automatically, so it is enough that you call this function on setup to define your device.</p>
<p >For keeping defaults use 0xffff/0xff for int/char values and null ptr for pointers.</p>
<dl class="section note"><dt>Note</dt><dd>You should set information so that it is unique over the world! Well if you are making device only for your own yacht N2k bus, it is enough to be unique there. So e.g. if you have two temperature monitors made by this library, you have to set at least first parameter UniqueNumber different for both of them. <br  />
</dd></dl>
<p>I just decided to use number one below maximum for ManufacturerCode as Open Source devices - this is not any number given by NMEA.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_UniqueNumber</td><td>Default=1. 21 bit resolution, max 2097151. Each device from same manufacturer should have unique number. </td></tr>
    <tr><td class="paramname">_DeviceFunction</td><td>Default=130, PC Gateway. See codes on <a href="https://web.archive.org/web/20190531120557/https://www.nmea.org/Assets/20120726%20nmea%202000%20class%20&%20function%20codes%20v%202.00.pdf">https://web.archive.org/web/20190531120557/https://www.nmea.org/Assets/20120726%20nmea%202000%20class%20&amp;%20function%20codes%20v%202.00.pdf</a> </td></tr>
    <tr><td class="paramname">_DeviceClass</td><td>Default=25, Inter/Intranetwork Device. See codes on <a href="https://web.archive.org/web/20190531120557/https://www.nmea.org/Assets/20120726%20nmea%202000%20class%20&%20function%20codes%20v%202.00.pdf">https://web.archive.org/web/20190531120557/https://www.nmea.org/Assets/20120726%20nmea%202000%20class%20&amp;%20function%20codes%20v%202.00.pdf</a> </td></tr>
    <tr><td class="paramname">_ManufacturerCode</td><td>Default=2046. Maximum 2046. See the list of codes on <a href="https://web.archive.org/web/20190529161431/http://www.nmea.org/Assets/20121020%20nmea%202000%20registration%20list.pdf">https://web.archive.org/web/20190529161431/http://www.nmea.org/Assets/20121020%20nmea%202000%20registration%20list.pdf</a> </td></tr>
    <tr><td class="paramname">_IndustryGroup</td><td>Default=4, Marine. </td></tr>
    <tr><td class="paramname">iDev</td><td>index of the device on Devices</td></tr>
  </table>
  </dd>
</dl>
<hr  />
<p> <a class="anchor" id="autotoc_md43"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#adbe4ba0aa4cf350a74f8e371b7c6a335" title="Set the Device Information Instances.">tNMEA2000::SetDeviceInformationInstances</a></h5>
<p >Set the Device Information Instances. With this function you can set device instance lower, device instance upper and system instance values.</p>
<p >For certified devices there is requirement that device instances can be externally changed. Library handles that as default, but developer has to take care that changed instances will be saved and restored on devices start.</p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="classt_n_m_e_a2000.html#ae3fb4cf2ef6601527153715e8c088e24" title="Check if this device has changed its DeviceInstances or SystemInstance.">tNMEA2000::ReadResetDeviceInformationChanged</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_DeviceInstanceLower</td><td>0xff means no change </td></tr>
    <tr><td class="paramname">_DeviceInstanceUpper</td><td><br  />
 </td></tr>
    <tr><td class="paramname">_SystemInstance</td><td><br  />
 </td></tr>
    <tr><td class="paramname">iDev</td><td>index of the device on Devices</td></tr>
  </table>
  </dd>
</dl>
<hr  />
<p> <a class="anchor" id="autotoc_md45"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#a254973b61424c1303c6f3c38dcabe9aa" title="Get the Device Information.">tNMEA2000::GetDeviceInformation</a></h5>
<p >Get the Device Information. With this function you can read current device information. Normally device information contains what you have set during initializing with <a class="el" href="classt_n_m_e_a2000.html#a1cb4d59a06724fcb32c6986b21c526a5">tNMEA2000::SetDeviceInformation</a> and <a class="el" href="classt_n_m_e_a2000.html#adbe4ba0aa4cf350a74f8e371b7c6a335">tNMEA2000::SetDeviceInformationInstances</a> functions.</p>
<dl class="section note"><dt>Note</dt><dd>Device information instances can be changed by the NMEA 2000 group function by e.g. using system configuration device. So you should time to time check if they have changed and save changed data to e.g. EEPROM for use on startup. <br  />
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="classt_n_m_e_a2000.html#ae3fb4cf2ef6601527153715e8c088e24">tNMEA2000::ReadResetDeviceInformationChanged</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iDev</td><td>index of the device on Devices</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const tDeviceInformation</dd></dl>
<hr  />
<p> <a class="anchor" id="autotoc_md47"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#af9a5602533a0af28ae483cc1cd0913fb" title="Set the Configuration Information of this device.">tNMEA2000::SetConfigurationInformation</a></h5>
<p >Set the Configuration Information of this device. With this function you can set configuration information for your device.</p>
<p >Configuration information contains some extra information about device installation and manufacturer. Some MFD shows it, some does not. NMEA Reader can show configuration information. InstallationDescription1 and InstallationDescription2 can be changed as default during runtime by NMEA 2000 group function commands. That can be done e.g. with NMEA Reader. <br  />
</p>
<dl class="section note"><dt>Note</dt><dd>You can disable configuration information by calling SetProgmemConfigurationInformation(0);</dd></dl>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="classt_n_m_e_a2000.html#a7db046fd7bc50a013a7931b1c3b0b0a5">tNMEA2000::GetInstallationDescription1</a></li>
<li><a class="el" href="classt_n_m_e_a2000.html#adefc5cb31bfa2f40e6b0145da501e366">tNMEA2000::GetInstallationDescription2</a></li>
<li><a class="el" href="classt_n_m_e_a2000.html#a343eb326c46fd23a03c39f44ee7f838a">tNMEA2000::ReadResetInstallationDescriptionChanged</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ManufacturerInformation</td><td>Buffer for Manufacturer information. Use e.g., company name and web address. </td></tr>
    <tr><td class="paramname">InstallationDescription1</td><td>Buffer for Installation Description 1. Installation Description 1 and 2 may be used by device installer e.g., for location of physical device to help to find it. To handle externally updated Installation Description you should listen changes of them. See <a class="el" href="classt_n_m_e_a2000.html#a343eb326c46fd23a03c39f44ee7f838a" title="Check if this device has changed its Install Description.">tNMEA2000::ReadResetInstallationDescriptionChanged</a> </td></tr>
    <tr><td class="paramname">InstallationDescription2</td><td>Buffer for Installation Description 2.</td></tr>
  </table>
  </dd>
</dl>
<hr  />
<p> <a class="anchor" id="autotoc_md49"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#aa81ac54c4a8899bc6ee29404a08fefb1" title="Set the Configuration Information located on PROGMEM.">tNMEA2000::SetProgmemConfigurationInformation</a></h5>
<p >Set the Configuration Information located on PROGMEM. With this function you can set configuration information, which will be saved on device program memory. See example BatteryMonitor.ino.</p>
<p >This function is useful only on MCUs with very small RAM. By using PROGMEM, installation description can not be changed by group function.</p>
<p >As default system has build in configuration information on progmem. If you do not want to have configuration information at all, you can disable it by calling SetConfigurationInformation(0);</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ManufacturerInformation</td><td>Buffer for Manufacturer information </td></tr>
    <tr><td class="paramname">InstallationDescription1</td><td>Buffer for Installation Description 1 </td></tr>
    <tr><td class="paramname">InstallationDescription2</td><td>Buffer for Installation Description 2</td></tr>
  </table>
  </dd>
</dl>
<hr  />
<p> <a class="anchor" id="autotoc_md51"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#ad43803ecc3b2aeaa5ee633321a6ff867" title="Set the library mode and start source address.">tNMEA2000::SetMode</a></h5>
<p >Set the library mode and start source address. With SetMode you can define how your node acts on N2k bus and set start source address. Source address setting has effect only on modes N2km_NodeOnly and N2km_ListenAndNode.</p>
<p >NMEA2000 standard requires that once your device has been connected to the bus, it uses last used address on next start. Due to address claiming, your device may change its source address, when you add new devices to the bus. So you should save last used address to e.g. EEPROM and on setup use it as parameter for SetMode. You can check if your address you set originally by SetMode has changed by using function <a class="el" href="classt_n_m_e_a2000.html#ad0763a8d6bec7d9dee647e9a695206f4" title="Check if this device has changed its address.">tNMEA2000::ReadResetAddressChanged()</a> and you can read current address by function <a class="el" href="classt_n_m_e_a2000.html#a7e56a37f568be6dc1862eee512ded770" title="Read address for current device.">tNMEA2000::GetN2kSource()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="pg_lib_ref.html#secDeviceModes">Device modes</a></li>
<li><a class="el" href="md_7_glossary.html#secRefTermAddressClaiming">Address claiming</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_N2kMode</td><td>Mode for this node, see tN2kMode </td></tr>
    <tr><td class="paramname">_N2kSource</td><td>Source address for this node</td></tr>
  </table>
  </dd>
</dl>
<p>Example how to init and save device source address.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="_temperature_monitor_8ino.html#a4fc01d736fe50cf5b977f755b675f11d">setup</a>() {</div>
<div class="line">...</div>
<div class="line">NMEA2000.SetMode(<a class="code hl_enumvalue" href="classt_n_m_e_a2000.html#a5af29eea6c5efd234d6f94ff3b6823c6a9b42ab0462e8df393c8ce78170926e18">tNMEA2000::N2km_NodeOnly</a>,GetLastSavedN2kAddressFromEEPROM());</div>
<div class="line">...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line">void <a class="code hl_function" href="_temperature_monitor_8ino.html#afe461d27b9c48d5921c00d521181f12f">loop</a>() {</div>
<div class="line">  <a class="code hl_function" href="_temperature_monitor_8ino.html#a0b1823a0c542414a27da4e142b7d7dff">SendN2kTemperature</a>();</div>
<div class="line">  <a class="code hl_variable" href="_n_m_e_a2000___c_a_n_8h.html#a99f6ed3fa2b0b15f276c856e10a7a3ab">NMEA2000</a>.<a class="code hl_function" href="classt_n_m_e_a2000.html#a19d8850b16c1204911ada74c267a5f6d">ParseMessages</a>();</div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code hl_variable" href="_n_m_e_a2000___c_a_n_8h.html#a99f6ed3fa2b0b15f276c856e10a7a3ab">NMEA2000</a>.<a class="code hl_function" href="classt_n_m_e_a2000.html#ad0763a8d6bec7d9dee647e9a695206f4">ReadResetAddressChanged</a>() ) {</div>
<div class="line">    SaveN2kAddressToEEPROM(GetN2kSource());</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="a_temperature_monitor_8ino_html_a0b1823a0c542414a27da4e142b7d7dff"><div class="ttname"><a href="_temperature_monitor_8ino.html#a0b1823a0c542414a27da4e142b7d7dff">SendN2kTemperature</a></div><div class="ttdeci">void SendN2kTemperature()</div><div class="ttdef"><b>Definition:</b> <a href="_temperature_monitor_8ino_source.html#l00097">TemperatureMonitor.ino:97</a></div></div>
<div class="ttc" id="a_temperature_monitor_8ino_html_a4fc01d736fe50cf5b977f755b675f11d"><div class="ttname"><a href="_temperature_monitor_8ino.html#a4fc01d736fe50cf5b977f755b675f11d">setup</a></div><div class="ttdeci">void setup()</div><div class="ttdef"><b>Definition:</b> <a href="_temperature_monitor_8ino_source.html#l00048">TemperatureMonitor.ino:48</a></div></div>
<div class="ttc" id="a_temperature_monitor_8ino_html_afe461d27b9c48d5921c00d521181f12f"><div class="ttname"><a href="_temperature_monitor_8ino.html#afe461d27b9c48d5921c00d521181f12f">loop</a></div><div class="ttdeci">void loop()</div><div class="ttdef"><b>Definition:</b> <a href="_temperature_monitor_8ino_source.html#l00081">TemperatureMonitor.ino:81</a></div></div>
<div class="ttc" id="aclasst_n_m_e_a2000_html_a19d8850b16c1204911ada74c267a5f6d"><div class="ttname"><a href="classt_n_m_e_a2000.html#a19d8850b16c1204911ada74c267a5f6d">tNMEA2000::ParseMessages</a></div><div class="ttdeci">void ParseMessages()</div><div class="ttdoc">Parse all incoming Messages.</div><div class="ttdef"><b>Definition:</b> <a href="_n_m_e_a2000_8cpp_source.html#l02577">NMEA2000.cpp:2577</a></div></div>
<div class="ttc" id="aclasst_n_m_e_a2000_html_a5af29eea6c5efd234d6f94ff3b6823c6a9b42ab0462e8df393c8ce78170926e18"><div class="ttname"><a href="classt_n_m_e_a2000.html#a5af29eea6c5efd234d6f94ff3b6823c6a9b42ab0462e8df393c8ce78170926e18">tNMEA2000::N2km_NodeOnly</a></div><div class="ttdeci">@ N2km_NodeOnly</div><div class="ttdef"><b>Definition:</b> <a href="_n_m_e_a2000_8h_source.html#l00695">NMEA2000.h:695</a></div></div>
<div class="ttc" id="aclasst_n_m_e_a2000_html_ad0763a8d6bec7d9dee647e9a695206f4"><div class="ttname"><a href="classt_n_m_e_a2000.html#ad0763a8d6bec7d9dee647e9a695206f4">tNMEA2000::ReadResetAddressChanged</a></div><div class="ttdeci">bool ReadResetAddressChanged()</div><div class="ttdoc">Check if this device has changed its address.</div><div class="ttdef"><b>Definition:</b> <a href="_n_m_e_a2000_8cpp_source.html#l02496">NMEA2000.cpp:2496</a></div></div>
</div><!-- fragment --><hr  />
<p> <a class="anchor" id="autotoc_md53"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#a6f875d0fcec2c5805d00fd44321a03f7" title="Extend the list of Transmitted Messages.">tNMEA2000::ExtendTransmitMessages</a></h5>
<p >Extend the list of Transmitted Messages. Define list of extra PGNs, what your system will transmit. System messages will be automatically included. Pointers must be in PROGMEM</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <a class="code hl_variable" href="_temperature_monitor_8ino.html#a99a54e36714d9ab35490dc8f2e020d4f">TransmitMessages</a>[] <a class="code hl_define" href="_n2k_def_8h.html#a75acaba9e781937468d0911423bc0c35">PROGMEM</a>={130310L,130311L,130312L,0};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_variable" href="_n_m_e_a2000___c_a_n_8h.html#a99f6ed3fa2b0b15f276c856e10a7a3ab">NMEA2000</a>.<a class="code hl_function" href="classt_n_m_e_a2000.html#a6f875d0fcec2c5805d00fd44321a03f7">ExtendTransmitMessages</a>(<a class="code hl_variable" href="_temperature_monitor_8ino.html#a99a54e36714d9ab35490dc8f2e020d4f">TransmitMessages</a>);</div>
<div class="ttc" id="a_n2k_def_8h_html_a75acaba9e781937468d0911423bc0c35"><div class="ttname"><a href="_n2k_def_8h.html#a75acaba9e781937468d0911423bc0c35">PROGMEM</a></div><div class="ttdeci">#define PROGMEM</div><div class="ttdef"><b>Definition:</b> <a href="_n2k_def_8h_source.html#l00045">N2kDef.h:45</a></div></div>
<div class="ttc" id="a_temperature_monitor_8ino_html_a99a54e36714d9ab35490dc8f2e020d4f"><div class="ttname"><a href="_temperature_monitor_8ino.html#a99a54e36714d9ab35490dc8f2e020d4f">TransmitMessages</a></div><div class="ttdeci">const unsigned long TransmitMessages[]</div><div class="ttdef"><b>Definition:</b> <a href="_temperature_monitor_8ino_source.html#l00025">TemperatureMonitor.ino:25</a></div></div>
<div class="ttc" id="aclasst_n_m_e_a2000_html_a6f875d0fcec2c5805d00fd44321a03f7"><div class="ttname"><a href="classt_n_m_e_a2000.html#a6f875d0fcec2c5805d00fd44321a03f7">tNMEA2000::ExtendTransmitMessages</a></div><div class="ttdeci">void ExtendTransmitMessages(const unsigned long *_TransmitMessages, int iDev=0)</div><div class="ttdoc">Extend the list of Transmitted Messages.</div><div class="ttdef"><b>Definition:</b> <a href="_n_m_e_a2000_8cpp_source.html#l01163">NMEA2000.cpp:1163</a></div></div>
</div><!-- fragment --><p >Library responds automatically to PGN 126464 request about transmit or receive messages. With this function you extend library list of messages your device own logic sends.</p>
<dl class="section note"><dt>Note</dt><dd>Extending transmit messages is required for <a class="el" href="md_7_glossary.html#secRefNMEA2000Certification">NMEA2000 certification</a>, may be also critical since some devices refuses to handle PGNs from devices, which does not list them on transmit messages.</dd></dl>
<p>This has only effect for device modes <a class="el" href="classt_n_m_e_a2000.html#a5af29eea6c5efd234d6f94ff3b6823c6a9b42ab0462e8df393c8ce78170926e18">tNMEA2000::N2km_NodeOnly</a> and <a class="el" href="classt_n_m_e_a2000.html#a5af29eea6c5efd234d6f94ff3b6823c6ac0fcabeda748be43650dce09d6fb4d7c">tNMEA2000::N2km_ListenAndNode</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_TransmitMessages</td><td>Buffer holding list of extra PGNs device will transmit. </td></tr>
    <tr><td class="paramname">iDev</td><td>index of the device on Devices</td></tr>
  </table>
  </dd>
</dl>
<hr  />
<p> <a class="anchor" id="autotoc_md55"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#a45ddd8fbf70df8de24e865c780c94284" title="Extend the list of Received Messages.">tNMEA2000::ExtendReceiveMessages</a></h5>
<p >Extend the list of Received Messages. Define list of extra PGNs, what your system will handle. System messages will be automatically included. <br  />
 Pointers must be in PROGMEM.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> ReceivedMessages[] <a class="code hl_define" href="_n2k_def_8h.html#a75acaba9e781937468d0911423bc0c35">PROGMEM</a>={130310L,130311L,130312L,0};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_variable" href="_n_m_e_a2000___c_a_n_8h.html#a99f6ed3fa2b0b15f276c856e10a7a3ab">NMEA2000</a>.<a class="code hl_function" href="classt_n_m_e_a2000.html#a45ddd8fbf70df8de24e865c780c94284">ExtendReceiveMessages</a>(ReceivedMessages);</div>
<div class="ttc" id="aclasst_n_m_e_a2000_html_a45ddd8fbf70df8de24e865c780c94284"><div class="ttname"><a href="classt_n_m_e_a2000.html#a45ddd8fbf70df8de24e865c780c94284">tNMEA2000::ExtendReceiveMessages</a></div><div class="ttdeci">void ExtendReceiveMessages(const unsigned long *_ReceiveMessages, int iDev=0)</div><div class="ttdoc">Extend the list of Received Messages.</div><div class="ttdef"><b>Definition:</b> <a href="_n_m_e_a2000_8cpp_source.html#l01170">NMEA2000.cpp:1170</a></div></div>
</div><!-- fragment --><p >Library responds automatically to PGN 126464 request about transmit or receive messages. With this function you extend library list of messages your device own logic listens.</p>
<dl class="section note"><dt>Note</dt><dd>Extending receive messages is required for <a class="el" href="md_7_glossary.html#secRefNMEA2000Certification">NMEA2000 certification</a>.</dd></dl>
<p>This has only effect for device modes <a class="el" href="classt_n_m_e_a2000.html#a5af29eea6c5efd234d6f94ff3b6823c6a9b42ab0462e8df393c8ce78170926e18">tNMEA2000::N2km_NodeOnly</a> and <a class="el" href="classt_n_m_e_a2000.html#a5af29eea6c5efd234d6f94ff3b6823c6ac0fcabeda748be43650dce09d6fb4d7c">tNMEA2000::N2km_ListenAndNode</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_ReceiveMessages</td><td>Buffer holding list of extra PGNs device will handle. </td></tr>
    <tr><td class="paramname">iDev</td><td>index of the device on Devices</td></tr>
  </table>
  </dd>
</dl>
<hr  />
<p> <a class="anchor" id="autotoc_md57"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#a8ac69d5d7a93a2d2066a7bf4344c6e1e" title="Set OnOpen callback function.">tNMEA2000::SetOnOpen</a></h5>
<p >Set OnOpen callback function. OnOpen will be called, when communication really opens and starts initial address claiming. You can use this to init your message sending to synchronize them with e.g., heartbeat.</p>
<dl class="section note"><dt>Note</dt><dd>In future OnOpen may be called several times, if communication will be reopened by Restart or driver error. Developer must take care that possible memory initializations will be handled properly in case OnOpen is called several times.</dd></dl>
<hr  />
<p> <a class="anchor" id="autotoc_md59"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#a6d2b2e0ffd57aca912cda44e868cd25b" title="Send message to the NMEA2000 bus.">tNMEA2000::SendMsg</a></h5>
<p >Send message to the NMEA2000 bus. Call this to send message to NMEA2000 bus. Before calling SendMsg() you have to prepare <a class="el" href="classt_n2k_msg.html" title="This class contains all the data of an NMEA2000 message.">tN2kMsg</a> type of message e.g. by using PGN specific function in <a class="el" href="_n2k_messages_8h.html" title="This File contains all SetXXX functions which will be needed to transfer data with a specific PGN.">N2kMessages.h</a>. <br  />
</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classt_n_m_e_a2000.html" title="tNMEA2000 device class definition.">tNMEA2000</a> object is as default in <a class="el" href="classt_n_m_e_a2000.html#a5af29eea6c5efd234d6f94ff3b6823c6a4cd03ae74ee5aa6a957d14c523af52d4">tNMEA2000::N2km_ListenOnly</a> mode. So if you want to send messages, you have to set right mode in setup with <a class="el" href="classt_n_m_e_a2000.html#ad43803ecc3b2aeaa5ee633321a6ff867" title="Set the library mode and start source address.">tNMEA2000::SetMode()</a>.</dd></dl>
<p>The function returns true, if the message was sent or buffered successfully, otherwise it return false. SendMsg may fail, if there is not room for message frames on sending buffer, device is not yet open or not ready to send.</p>
<p >If you sent single frame message time to time, it will normally go directly to CAN controller sent "mailbox", where controller sends it as soon as it gets time from bus. Sending fastpacket message will always buffer at least other than first frame. Internally sent buffer is devided to driver buffer and library buffer. Driver buffer will empty by interrupt and library buffer on call to SendMsg or ParseMessages, which moves frames to driver buffer. To have reliable sending, you need a sending buffer, which is large enough for your device needs. See <a class="el" href="classt_n_m_e_a2000.html#a5e09e469c4126963e26802c4541117bb" title="Set CAN send frame buffer size.">tNMEA2000::SetN2kCANSendFrameBufSize</a>.</p>
<p >See example <a class="el" href="_temperature_monitor_8ino.html" title="NMEA2000 library example. Send main cabin and water temperatures to the bus.">TemperatureMonitor.ino</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="page_h_w_set_up.html#secCommErr">Most common hardware errors</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N2kMsg</td><td>Reference to a N2kMsg Object </td></tr>
    <tr><td class="paramname">DeviceIndex</td><td>index of the device on Devices <br  />
 Setting DeviceIndex to -1 forces library to use source address of N2kMsg instead of device source address. This is useful with e.g., passthrough gateway devices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Message sent or buffered successfully. </td></tr>
    <tr><td class="paramname">false</td><td>Open has not finished. Address claiming has not finished. There is no more room on send buffer, which may be caused by too small send buffer or CAN controller can not sent messages bus.</td></tr>
  </table>
  </dd>
</dl>
<hr  />
<p> <a class="anchor" id="autotoc_md61"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#a19d8850b16c1204911ada74c267a5f6d" title="Parse all incoming Messages.">tNMEA2000::ParseMessages</a></h5>
<p >Parse all incoming Messages. You have to call this periodically on <a class="el" href="_temperature_monitor_8ino.html#afe461d27b9c48d5921c00d521181f12f">loop()</a> to handle N2k messages, otherwise <a class="el" href="classt_n_m_e_a2000.html" title="tNMEA2000 device class definition.">tNMEA2000</a> object will not work at all.</p>
<dl class="section note"><dt>Note</dt><dd>Do not use delay() on your <a class="el" href="_temperature_monitor_8ino.html#afe461d27b9c48d5921c00d521181f12f">loop()</a>. Also take care that any library you use does not use delay() or any blocking function internally.</dd></dl>
<p>With NMEA2000 library you should use only nonblocking calls/libraries in your loop. Any library you use, should work asynchronously and not cause long delays on loop. Randomly caused 10-40 ms delays are acceptable. E.g., simple ADC conversion may block loop for 300 ms, which you will then see by other device dropping your device from the list.</p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="pg_lib_ref.html#descRunningLibrary">Running library</a>.</li>
<li><a class="el" href="classt_n_m_e_a2000.html#a944240f03999812fc365a00bc2b37d47">tNMEA2000::SetN2kCANReceiveFrameBufSize()</a></li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Even if you only send e.g. temperature to the bus, you should call this so the node will automatically inform about itself to others.</dd></dl>
<p>See example <a class="el" href="_temperature_monitor_8ino.html" title="NMEA2000 library example. Send main cabin and water temperatures to the bus.">TemperatureMonitor.ino</a>.</p>
<hr  />
<p> <a class="anchor" id="autotoc_md63"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#a2b1d83c0992c9eef88867723f634c883" title="Set the message handler for incoming NMEA2000 messages.">tNMEA2000::SetMsgHandler</a></h5>
<p >Set the message handler for incoming NMEA2000 messages. If you want to do something with messages read from N2k bus, easiest is to set message handler, which will be then called by ParseMessages for each new message.</p>
<p >If you have LCD display on your device and you want to show e.g., fluid level on it, create message handler, parse fluid level messages and draw value to display.</p>
<p >See example DataDisplay.ino or DataDisplay2.ino</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_MsgHandler</td><td>Old style - callback function pointer</td></tr>
  </table>
  </dd>
</dl>
<hr  />
<p> <a class="anchor" id="autotoc_md65"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#a41f9389afaaba6eeff8818a7945a9f99" title="Attach a message handler for incoming N2kMessages.">tNMEA2000::AttachMsgHandler</a></h5>
<p >Attach a message handler for incoming N2kMessages. <a class="el" href="classt_n_m_e_a2000.html#a2b1d83c0992c9eef88867723f634c883">tNMEA2000::SetMsgHandler</a> allows you to define only one handler to your system. If you like to do it by using classes, I prefer to use AttachMsgHandler. In this way you can e.g. define own class for each PGN and attach/detach them within your program.</p>
<p >Example NMEA2000ToNMEA0183 uses AttachMsgHandler. Due to logic it still has single class and so handles all PGNs.</p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="classt_n_m_e_a2000.html#ae93cb420bf0b8608a3b78edcad1c154b">tNMEA2000::DetachMsgHandler</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_MsgHandler</td><td>Message handler</td></tr>
  </table>
  </dd>
</dl>
<hr  />
<p> <a class="anchor" id="autotoc_md67"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#ae93cb420bf0b8608a3b78edcad1c154b" title="Detach a message handler for incoming N2kMessages.">tNMEA2000::DetachMsgHandler</a></h5>
<p >Detach a message handler for incoming N2kMessages. With DetachMsgHandler you can remove your handler from the handler stack. This is useful, if you do not want to handle some messages anymore.</p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="classt_n_m_e_a2000.html#a41f9389afaaba6eeff8818a7945a9f99">tNMEA2000::AttachMsgHandler</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_MsgHandler</td><td>Message handler</td></tr>
  </table>
  </dd>
</dl>
<hr  />
<p> <a class="anchor" id="autotoc_md69"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#a1a3c14ee0a90bcdee2c2d8446db00805" title="Set the message handler for incoming ISO Requests.">tNMEA2000::SetISORqstHandler</a></h5>
<p >Set the message handler for incoming ISO Requests. Devices on N2k bus may request PGN from your device. Certified devices should respond to requests to any transmit PGN listed. Write your own request handler and set it with this function.</p>
<p >The handler will be called by <a class="el" href="classt_n_m_e_a2000.html#a19d8850b16c1204911ada74c267a5f6d" title="Parse all incoming Messages.">tNMEA2000::ParseMessages</a>, if there is ISO request. <br  />
</p>
<dl class="section note"><dt>Note</dt><dd>When you send request message with <a class="el" href="classt_n_m_e_a2000.html#a6d2b2e0ffd57aca912cda44e868cd25b" title="Send message to the NMEA2000 bus.">tNMEA2000::SendMsg</a> and it fails, it is your responsibility to take care of sending response again later. If your sending buffer is large enough, it is very uncommon that <a class="el" href="classt_n_m_e_a2000.html#a6d2b2e0ffd57aca912cda44e868cd25b" title="Send message to the NMEA2000 bus.">tNMEA2000::SendMsg</a> fails.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ISORequestHandler</td><td>Message handler</td></tr>
  </table>
  </dd>
</dl>
<hr  />
<p> <a class="anchor" id="autotoc_md71"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#a7e56a37f568be6dc1862eee512ded770" title="Read address for current device.">tNMEA2000::GetN2kSource</a></h5>
<p >Read address for current device. With this function you can get you device current source address on the N2k bus. <br  />
</p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="classt_n_m_e_a2000.html#ad43803ecc3b2aeaa5ee633321a6ff867">tNMEA2000::SetMode</a></li>
<li><a class="el" href="classt_n_m_e_a2000.html#ae4ce4bfc4f7f4f7eb211569124cf1f65">tNMEA2000::SetN2kSource</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DeviceIndex</td><td>index of the device on Devices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unsigned char -&gt; Address of the device</dd></dl>
<hr  />
<p> <a class="anchor" id="autotoc_md73"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#ae4ce4bfc4f7f4f7eb211569124cf1f65" title="Set source for the given device.">tNMEA2000::SetN2kSource</a></h5>
<p >Set source for the given device. With this function you can set you device source address on the N2k bus. This is meant to be use for multi device on basic configuration to restore source address changed by address claiming. <br  />
</p>
<p >This function has to be called after <a class="el" href="classt_n_m_e_a2000.html#ad43803ecc3b2aeaa5ee633321a6ff867">tNMEA2000::SetMode()</a> and before <a class="el" href="classt_n_m_e_a2000.html#a5a98e0686a41aed891a62e565060f9f7">tNMEA2000::Open()</a></p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="classt_n_m_e_a2000.html#ad43803ecc3b2aeaa5ee633321a6ff867">tNMEA2000::SetMode</a></li>
<li><a class="el" href="classt_n_m_e_a2000.html#ae4ce4bfc4f7f4f7eb211569124cf1f65">tNMEA2000::SetN2kSource</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_iAddr</td><td>Address of the device </td></tr>
    <tr><td class="paramname">_iDev</td><td>index of the device on Devices</td></tr>
  </table>
  </dd>
</dl>
<hr  />
<p> <a class="anchor" id="autotoc_md75"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#ad0763a8d6bec7d9dee647e9a695206f4" title="Check if this device has changed its address.">tNMEA2000::ReadResetAddressChanged</a></h5>
<p >Check if this device has changed its address. With this function you can check has your device address you initiated with SetMode been changed after last call.</p>
<dl class="section note"><dt>Note</dt><dd>For certified NMEA 2000 devices it is mandatory save changed address to e.g. EEPROM, for use in next startup. <br  />
</dd></dl>
<p>When you call this, <a class="el" href="classt_n_m_e_a2000.html#a42e5cb9ae374b21f1233314c843d27d7">tNMEA2000::AddressChanged</a> will be reset. Anyway, if system for some reason needs to change its address again, <a class="el" href="classt_n_m_e_a2000.html#a42e5cb9ae374b21f1233314c843d27d7">tNMEA2000::AddressChanged</a> will be set. So you can e.g. in every 10 min check has address changed and if it has, save it.</p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="classt_n_m_e_a2000.html#ad43803ecc3b2aeaa5ee633321a6ff867">tNMEA2000::SetMode</a></li>
<li><a class="el" href="classt_n_m_e_a2000.html#ae4ce4bfc4f7f4f7eb211569124cf1f65">tNMEA2000::SetN2kSource</a></li>
</ul>
</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Some device source address changed. Read new values and save them. </td></tr>
    <tr><td class="paramname">false</td><td>Nothing changed, no further actions required.</td></tr>
  </table>
  </dd>
</dl>
<hr  />
<p> <a class="anchor" id="autotoc_md77"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#ae3fb4cf2ef6601527153715e8c088e24" title="Check if this device has changed its DeviceInstances or SystemInstance.">tNMEA2000::ReadResetDeviceInformationChanged</a></h5>
<p >Check if this device has changed its DeviceInstances or SystemInstance. With this function you can check has your device device instances or system instances changed.</p>
<dl class="section note"><dt>Note</dt><dd>For certified NMEA 2000 devices it is mandatory save changed info to e.g. EEPROM, for initialize them in next startup. <br  />
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="classt_n_m_e_a2000.html#adbe4ba0aa4cf350a74f8e371b7c6a335">tNMEA2000::SetDeviceInformationInstances</a></li>
<li><a class="el" href="classt_n_m_e_a2000.html#a254973b61424c1303c6f3c38dcabe9aa">tNMEA2000::GetDeviceInformation</a></li>
</ul>
</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Some device information changed. Read new values and save them. </td></tr>
    <tr><td class="paramname">false</td><td>Nothing changed, no further actions required.</td></tr>
  </table>
  </dd>
</dl>
<hr  />
<p> <a class="anchor" id="autotoc_md79"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#a343eb326c46fd23a03c39f44ee7f838a" title="Check if this device has changed its Install Description.">tNMEA2000::ReadResetInstallationDescriptionChanged</a></h5>
<p >Check if this device has changed its Install Description. </p><dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="classt_n_m_e_a2000.html#a7db046fd7bc50a013a7931b1c3b0b0a5">tNMEA2000::GetInstallationDescription1</a></li>
<li><a class="el" href="classt_n_m_e_a2000.html#adefc5cb31bfa2f40e6b0145da501e366">tNMEA2000::GetInstallationDescription2</a></li>
<li><a class="el" href="classt_n_m_e_a2000.html#af9a5602533a0af28ae483cc1cd0913fb">tNMEA2000::SetConfigurationInformation</a></li>
</ul>
</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Installation description changed. Read new values and save them. </td></tr>
    <tr><td class="paramname">false</td><td>Nothing changed, no further actions required.</td></tr>
  </table>
  </dd>
</dl>
<hr  />
<p> <a class="anchor" id="autotoc_md81"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#afaee7e8972200217c229b7d471175562" title="Set the count of devices library shows on bus.">tNMEA2000::SetDeviceCount</a></h5>
<p >Set the count of devices library shows on bus. With this function you can enable multi device support. As default there is only one device.</p>
<dl class="section note"><dt>Note</dt><dd>To enable multi device support, you need to call this before any other <a class="el" href="classt_n_m_e_a2000.html" title="tNMEA2000 device class definition.">tNMEA2000</a> class function.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="pg_lib_ref.html#descMultiDeviceSupport">Multi device support</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_DeviceCount</td><td>Maximum number of devices that can be hold in Devices</td></tr>
  </table>
  </dd>
</dl>
<hr  />
<p> <a class="anchor" id="autotoc_md83"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#a3d14fbb4a2758cea27c8fa1b06712c62" title="Set incoming CAN message (tNMEA2000::N2kCANMsgBuf) buffer size.">tNMEA2000::SetN2kCANMsgBufSize</a></h5>
<p >Set incoming CAN message (<a class="el" href="classt_n_m_e_a2000.html#a18e81ce0a8b0183897123694d7c582ca">tNMEA2000::N2kCANMsgBuf</a>) buffer size. With this function you can set size of buffer, where system builds incoming messages. The default size is 5 messages. Some messages are just single frame messages and they will be read in and handled immediately on call to ParseMessages. NMEA2000 fast packet message contains several frames sent sequentially. Anyway there can be other message frames between fast packet message frames, so these messages will be buffered and saved until all frames has been received. NMEA2000 requires that device should be able to read 2 concurrent fast packet and 2 ISO TP message. Since also single frame message requires one buffer slot buffer default size has been set to 5.</p>
<p >If buffer size is too small, there is risk that all fast packet messages will not be handled. Even your own logic does not listen any fast packet messages, internal logic listens group functions PGN 126208, which may contain important requests library should respond. If library does not respond to all required requests, there is risk that other devices drops your device information.</p>
<p >Since ISO TP messages are rarely used, with buffer size 5 library can handle 4 concurrent fast packet messages. Due to priorities this is enough in most cases. If bus has lot of devices sending fast packets and you have enough memory on MCU, you can increase buffer size. Buffer size 10 should be enough even on heavy traffic.</p>
<p >Function has to be called before communication opens. See <a class="el" href="classt_n_m_e_a2000.html#a5a98e0686a41aed891a62e565060f9f7">tNMEA2000::Open()</a>.</p>
<p >Do not mix this with <a class="el" href="classt_n_m_e_a2000.html#a944240f03999812fc365a00bc2b37d47" title="Set CAN receive frame buffer size.">tNMEA2000::SetN2kCANReceiveFrameBufSize()</a>, which has different meaning.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_MaxN2kCANMsgs</td><td>Number of CAN messages that can be stored in <a class="el" href="classt_n_m_e_a2000.html#a18e81ce0a8b0183897123694d7c582ca">tNMEA2000::N2kCANMsgBuf</a></td></tr>
  </table>
  </dd>
</dl>
<hr  />
<p> <a class="anchor" id="autotoc_md85"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#a5e09e469c4126963e26802c4541117bb" title="Set CAN send frame buffer size.">tNMEA2000::SetN2kCANSendFrameBufSize</a></h5>
<p >Set CAN send frame buffer size. With this function you can set size of buffer, where system saves frames of messages to be sent. Given buffer size will be devided to driver buffer and library buffer. Driver buffer will empty by driver interrupt and library buffer by call to SendMsg or ParseMessages, which moves frames to driver buffer. If driver can handle large buffer, library buffer will be set to minimum.</p>
<p >When sending long messages like ProductInformation or GNSS data, there may not be enough buffers for successfully send data. This depends of your hw and device source. Device source has effect due to priority of getting sending time. If your data is critical, use buffer size, which is large enough (default 40 frames).</p>
<p >E.g. Product information takes totally 134 bytes. This needs 20 frames. If you also send GNSS 47 bytes=7 frames. If you want to be sure that both will be sent on any situation, you need at least 27 frame buffer size.</p>
<p >If you use this function, call it once before <a class="el" href="classt_n_m_e_a2000.html#a5a98e0686a41aed891a62e565060f9f7">tNMEA2000::Open()</a> and before any device related function like <a class="el" href="classt_n_m_e_a2000.html#a08b0d31c74617227329406d948059a76" title="Set the Product Information of this device.">tNMEA2000::SetProductInformation</a>. If you call it later, function has no effect.</p>
<p >Driver may override your setting, if you set too small or too large buffer size. This is driver dependent behaviour.</p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="classt_n_m_e_a2000.html#a6d2b2e0ffd57aca912cda44e868cd25b">tNMEA2000::SendMsg</a></li>
<li><a class="el" href="classt_n_m_e_a2000.html#a19d8850b16c1204911ada74c267a5f6d">tNMEA2000::ParseMessages</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_MaxCANSendFrames</td><td>Maximum number of CAN frames that can be buffered in <a class="el" href="classt_n_m_e_a2000.html#afc3a2dd4532d2e529fdb5e648e5c301c">tNMEA2000::CANSendFrameBuf</a></td></tr>
  </table>
  </dd>
</dl>
<hr  />
<p> <a class="anchor" id="autotoc_md87"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#a944240f03999812fc365a00bc2b37d47" title="Set CAN receive frame buffer size.">tNMEA2000::SetN2kCANReceiveFrameBufSize</a></h5>
<p >Set CAN receive frame buffer size. Some CAN drivers allows interrupted receive frame buffering. You can set receive buffer size with this function. If you use this function, call it once before <a class="el" href="classt_n_m_e_a2000.html#a5a98e0686a41aed891a62e565060f9f7">tNMEA2000::Open()</a>;</p>
<p >Driver may override your setting, if you set too small or too large buffer size. This is driver dependent behaviour.</p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="classt_n_m_e_a2000.html#a19d8850b16c1204911ada74c267a5f6d">tNMEA2000::ParseMessages</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_MaxCANReceiveFrames</td><td>{type}</td></tr>
  </table>
  </dd>
</dl>
<hr  />
<p> <a class="anchor" id="autotoc_md89"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#a237d24922d17de047e1813b712f93640" title="Set the list of known Single Frame Messages.">tNMEA2000::SetSingleFrameMessages</a></h5>
<p >Set the list of known Single Frame Messages. Call these if you wish to override the default message packets supported. Pointers must be in PROGMEM</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> SingleFrameMessages[] <a class="code hl_define" href="_n2k_def_8h.html#a75acaba9e781937468d0911423bc0c35">PROGMEM</a>={......L,0};</div>
</div><!-- fragment --><p >As a default library has a list of known messages. With this function user can override default list of single frame messages.</p>
<p >Known single frame message lists has only effect if you limit handling with <a class="el" href="classt_n_m_e_a2000.html#abf8ed42c2350373212552ce94427e7a5" title="Is handle only known messages enabled.">tNMEA2000::HandleOnlyKnownMessages</a> or use message forwarding and limit it with <a class="el" href="classt_n_m_e_a2000.html#a36a00385b554ec225cab2819f6371d8f" title="Enable Only Known Messages for forwarding.">tNMEA2000::SetForwardOnlyKnownMessages</a></p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="classt_n_m_e_a2000.html#a18f52350426dd9f49f922a9ee16e2851">tNMEA2000::ExtendSingleFrameMessages</a>.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_SingleFrameMessages</td><td>Buffer holding single frame messages</td></tr>
  </table>
  </dd>
</dl>
<hr  />
<p> <a class="anchor" id="autotoc_md91"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#a04341b0e2045d8988d690f4fe5cb0bc3" title="Set the list of known Fast Packet Messages.">tNMEA2000::SetFastPacketMessages</a></h5>
<p >Set the list of known Fast Packet Messages. Call these if you wish to override the default message packets supported. Pointers must be in PROGMEM</p>
<p >As a default library has a list of known messages. With this function user can override default list of fast packet messages. Build in default list contains all fastpackets found from open information.</p>
<dl class="section note"><dt>Note</dt><dd>If an incoming fast packet message is not known, it will be treated as single frame message. So if you want to handle unknown fast packet message, you need to duplicate frame collection logic from library to your code. So it is easier to have fast packet messages listed on library, if you want to handle them.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="classt_n_m_e_a2000.html#a94555c94f270052702009d9581f73bfe">tNMEA2000::ExtendFastPacketMessages</a>.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_FastPacketMessages</td><td>Buffer holding fast packet messages</td></tr>
  </table>
  </dd>
</dl>
<hr  />
<p> <a class="anchor" id="autotoc_md93"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#a18f52350426dd9f49f922a9ee16e2851" title="Set the list of known Extended Single Frame Messages.">tNMEA2000::ExtendSingleFrameMessages</a></h5>
<p >Set the list of known Extended Single Frame Messages. Call these if you wish to add own list of supported message packets. Pointers must be in PROGMEM</p>
<p >As a default library has a list of known messages. With this function user can add own list of known single frame messages.</p>
<p >Known single frame message lists has only effect if you limit handling with <a class="el" href="classt_n_m_e_a2000.html#abf8ed42c2350373212552ce94427e7a5" title="Is handle only known messages enabled.">tNMEA2000::HandleOnlyKnownMessages</a> or use message forwarding and limit it with <a class="el" href="classt_n_m_e_a2000.html#a36a00385b554ec225cab2819f6371d8f" title="Enable Only Known Messages for forwarding.">tNMEA2000::SetForwardOnlyKnownMessages</a></p>
<dl class="section note"><dt>Note</dt><dd>Currently subsequent calls will override previously set list.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><ul>
<li>SetSingleFrameMessages</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_SingleFrameMessages</td><td>Buffer holding single frame messages</td></tr>
  </table>
  </dd>
</dl>
<hr  />
<p> <a class="anchor" id="autotoc_md95"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#a94555c94f270052702009d9581f73bfe" title="Set the list of known Extended Fast Packet Messages.">tNMEA2000::ExtendFastPacketMessages</a></h5>
<p >Set the list of known Extended Fast Packet Messages. Call these if you wish to extent list of fast packet messages. Pointers must be in PROGMEM</p>
<p >As a default library has a list of known messages. With this function user can extent default list of fast packet messages.</p>
<dl class="section note"><dt>Note</dt><dd>If an incoming fast packet message is not known, it will be treated as single frame message. So if you want to handle unknown fast packet message, you need to duplicate frame collection logic from library to your code. So it is easier to have fast packet messages listed on library, if you want to handle them.</dd>
<dd>
Currently subsequent calls will override previously set list.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="classt_n_m_e_a2000.html#a04341b0e2045d8988d690f4fe5cb0bc3">tNMEA2000::SetFastPacketMessages</a>.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_FastPacketMessages</td><td>Buffer holding extended fast packet messages</td></tr>
  </table>
  </dd>
</dl>
<hr  />
<p> <a class="anchor" id="autotoc_md97"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#a561a8cdcb18ef59dc9ef3d93a26d4e36" title="Send an IsoAddressClaim message.">tNMEA2000::SendIsoAddressClaim</a></h5>
<p >This is automatically used by class. You only need to use this, if you want to write your own behavior for address claiming.</p>
<hr  />
<p> <a class="anchor" id="autotoc_md99"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#ac6ba6daeaea5ec94f7ce3920ca622e2b" title="Send a Product Information message.">tNMEA2000::SendProductInformation</a></h5>
<p >This is automatically used by class. You only need to use this, if you want to write your own behavior for providing product information.</p>
<hr  />
<p> <a class="anchor" id="autotoc_md101"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#a33b6fab401d849b834c16de03d5e37a3" title="Send a Config Information message.">tNMEA2000::SendConfigurationInformation</a></h5>
<p >This is automatically used by class. You only need to use this, if you want to write your own behavior for providing configuration information.</p>
<hr  />
<p> <a class="anchor" id="autotoc_md103"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#a856d0935f458556c9c9471772b00a047" title="Set the Heartbeat Interval and Offset for a device.">tNMEA2000::SetHeartbeatIntervalAndOffset</a></h5>
<p >Set the Heartbeat Interval and Offset for a device. Library will automatically start heartbeat with default interval 60 s and offset 10 s.</p>
<p >According to document <a href="https://web.archive.org/web/20170609023206/https://www.nmea.org/Assets/20140102%20nmea-2000-126993%20heartbeat%20pgn%20corrigendum.pdf">NMEA Heartbeat Corrigendum</a> all NMEA devices shall transmit heartbeat PGN 126993. With this function you can set transmission interval in ms (range 1000-655320ms , default 60000). Set interval 0 to disable heartbeat</p>
<p >Function allows to set interval over 60 s or 0 to disable sending for test purposes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interval</td><td>Heartbeat Interval in ms. 0xffffffff=keep current, 0xfffffffe=restore default </td></tr>
    <tr><td class="paramname">offset</td><td>Heartbeat Offset in ms. 0xffffffff=keep current, 0xfffffffe=restore default </td></tr>
    <tr><td class="paramname">iDev</td><td>Index of the device on Devices or -1 to set for all.</td></tr>
  </table>
  </dd>
</dl>
<hr  />
<p> <a class="anchor" id="autotoc_md105"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#a6fb1b392658f77da619fda7af2d1ec66" title="Get the Heartbeat Interval of a device.">tNMEA2000::GetHeartbeatInterval</a></h5>
<p >Get the Heartbeat Interval of a device. Heartbeat interval may be changed by e.g. MFD by group function. I have not yet found should changed value be saved for next startup or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iDev</td><td>index of the device on Devices </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">uint_32</td><td>Device heartbeat interval in ms</td></tr>
  </table>
  </dd>
</dl>
<hr  />
<p> <a class="anchor" id="autotoc_md107"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#a0722fbc4d1f41f54b77bdeee31daa292" title="Send heartbeat for specific device.">tNMEA2000::SendHeartbeat</a></h5>
<p >Library will automatically send heartbeat, if interval is &gt;0. You can also manually send it any time or force sent, if interval=0;</p>
<hr  />
<p> <a class="anchor" id="autotoc_md109"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#af8e42fa479186803223f48f6b5e761c3" title="Set the Forward Streaming Type.">tNMEA2000::SetForwardType</a></h5>
<p >Set the Forward Streaming Type. With this function user can set how messages will be forwarded to the stream. Possible values are:</p><ul>
<li><a class="el" href="classt_n_m_e_a2000.html#a61a89a29106cc1b3ff6d8b1bfbbc6cabade8c6866ae9d5992c217b5bce4b139d7">tNMEA2000::fwdt_Actisense</a> (default) forwards messages is Actisense format. Some navigation softwares can read this format.</li>
<li><a class="el" href="classt_n_m_e_a2000.html#a61a89a29106cc1b3ff6d8b1bfbbc6caba8f0e6b11905fdbf0c47e3315597e79fc">tNMEA2000::fwdt_Text</a> forwards messages to output port in clear text. I see this useful only for testing with normal serial monitors.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fwdType</td><td>Format type see <a class="el" href="classt_n_m_e_a2000.html#a61a89a29106cc1b3ff6d8b1bfbbc6cab">tNMEA2000::tForwardType</a>, default = fwdt_Actisense</td></tr>
  </table>
  </dd>
</dl>
<hr  />
<p> <a class="anchor" id="autotoc_md111"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#a2d9e7390622f0aaa3dd96e753d0f3ab7" title="Set the Forward Stream object.">tNMEA2000::SetForwardStream</a></h5>
<p >Set the Forward Stream object. As default, forward stream has been set to null. For e.g. Arduino Due you can set it to SerialUSB, so you can use Serial for other things. You can of coarse use any stream available on your device. <br  />
 See example ActisenseListenerSender.ino.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_stream</td><td>Stream to be used for message forwarding</td></tr>
  </table>
  </dd>
</dl>
<hr  />
<p> <a class="anchor" id="autotoc_md113"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#a5a98e0686a41aed891a62e565060f9f7" title="Open the CAN device.">tNMEA2000::Open</a></h5>
<p >Open the CAN device. You can call this on Setup(). It will be called anyway automatically by first call of <a class="el" href="classt_n_m_e_a2000.html#a19d8850b16c1204911ada74c267a5f6d" title="Parse all incoming Messages.">tNMEA2000::ParseMessages()</a>. When system is finally opened, OnOpen callback will be executed. See <a class="el" href="classt_n_m_e_a2000.html#a8ac69d5d7a93a2d2066a7bf4344c6e1e">tNMEA2000::SetOnOpen</a></p>
<dl class="section note"><dt>Note</dt><dd>After <a class="el" href="classt_n_m_e_a2000.html#a5a98e0686a41aed891a62e565060f9f7" title="Open the CAN device.">tNMEA2000::Open()</a> you should start loop <a class="el" href="classt_n_m_e_a2000.html#a19d8850b16c1204911ada74c267a5f6d" title="Parse all incoming Messages.">tNMEA2000::ParseMessages()</a> without delays. If you e.g., call first <a class="el" href="classt_n_m_e_a2000.html#a5a98e0686a41aed891a62e565060f9f7" title="Open the CAN device.">tNMEA2000::Open()</a> and then start to read configuration from slow flash, address claiming will not work properly.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td></td></tr>
    <tr><td class="paramname">false</td><td></td></tr>
  </table>
  </dd>
</dl>
<hr  />
<p> <a class="anchor" id="autotoc_md115"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#a1981274e03fd52798eda7302b48ea169" title="Enable message forwarding to stream.">tNMEA2000::EnableForward</a></h5>
<p >Enable message forwarding to stream. Set true as default. With this you can control if bus messages will be forwarded to forward stream. <br  />
</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="pg_lib_ref.html#secMessageforwarding">Message forwarding</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Enable, default = true</td></tr>
  </table>
  </dd>
</dl>
<hr  />
<p> <a class="anchor" id="autotoc_md117"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#a205933011fd3895e30d134016a086faa" title="Enable System Messages for forwarding.">tNMEA2000::SetForwardSystemMessages</a></h5>
<p >Enable System Messages for forwarding. Set true as default. With this you can control if system messages like address claiming, device information will be forwarded to forward stream. If you set this false, system messages will not be forwarded to the stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Enable, default = true</td></tr>
  </table>
  </dd>
</dl>
<hr  />
<p> <a class="anchor" id="autotoc_md119"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#a36a00385b554ec225cab2819f6371d8f" title="Enable Only Known Messages for forwarding.">tNMEA2000::SetForwardOnlyKnownMessages</a></h5>
<p >Enable Only Known Messages for forwarding. Set false as default. With this you can control if unknown messages will be forwarded to forward stream. If you set this true, all unknown message will not be forwarded to the stream.</p>
<dl class="section note"><dt>Note</dt><dd>This does not effect for own messages. Known messages are listed on library. <br  />
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="classt_n_m_e_a2000.html#a237d24922d17de047e1813b712f93640">tNMEA2000::SetSingleFrameMessages</a></li>
<li><a class="el" href="classt_n_m_e_a2000.html#a04341b0e2045d8988d690f4fe5cb0bc3">tNMEA2000::SetFastPacketMessages</a></li>
<li><a class="el" href="classt_n_m_e_a2000.html#a18f52350426dd9f49f922a9ee16e2851">tNMEA2000::ExtendSingleFrameMessages</a></li>
<li><a class="el" href="classt_n_m_e_a2000.html#a94555c94f270052702009d9581f73bfe">tNMEA2000::ExtendFastPacketMessages</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Enable, default = false</td></tr>
  </table>
  </dd>
</dl>
<hr  />
<p> <a class="anchor" id="autotoc_md121"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#a3b1e14f74064caed4c3583bfbbe13134" title="Enable Own Messages for forwarding.">tNMEA2000::SetForwardOwnMessages</a></h5>
<p >Enable Own Messages for forwarding. Set true as default. With this you can control if messages your device sends to bus will be forwarded to forward stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Enable, default = true</td></tr>
  </table>
  </dd>
</dl>
<hr  />
<p> <a class="anchor" id="autotoc_md123"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#ad19aa8b317d1ecca5992b0e419209909" title="Set the Handle Only Known Messages.">tNMEA2000::SetHandleOnlyKnownMessages</a></h5>
<p >Set the Handle Only Known Messages. Set false as default. With this you can control if unknown messages will be handled at all. Known messages are listed on library.</p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="classt_n_m_e_a2000.html#a237d24922d17de047e1813b712f93640">tNMEA2000::SetSingleFrameMessages</a></li>
<li><a class="el" href="classt_n_m_e_a2000.html#a04341b0e2045d8988d690f4fe5cb0bc3">tNMEA2000::SetFastPacketMessages</a></li>
<li><a class="el" href="classt_n_m_e_a2000.html#a18f52350426dd9f49f922a9ee16e2851">tNMEA2000::ExtendSingleFrameMessages</a></li>
<li><a class="el" href="classt_n_m_e_a2000.html#a94555c94f270052702009d9581f73bfe">tNMEA2000::ExtendFastPacketMessages</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Enable, default = false</td></tr>
  </table>
  </dd>
</dl>
<hr  />
<p> <a class="anchor" id="autotoc_md125"></a> </p><h5><a class="el" href="classt_n_m_e_a2000.html#a43fb8be0ab5036dff662192b04d20314" title="Set the Debug Mode of the system.">tNMEA2000::SetDebugMode</a></h5>
<p >Set the Debug Mode of the system. If you do not have physical N2k bus connection and you like to test your board without even CAN controller, you can use this function. <br  />
</p>
<dl class="section see"><dt>See also</dt><dd><ul>
<li><a class="el" href="pg_lib_ref.html#descDebugMode">Debug mode</a></li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_dbMode</td><td>Debug mode, see <a class="el" href="classt_n_m_e_a2000.html#ae34b9115f8c45d6622089516a6d62c06">tNMEA2000::tDebugMode</a> </td></tr>
  </table>
  </dd>
</dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->

<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
